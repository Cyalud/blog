---
title: 深入理解JAVA虚拟机（二）  HotSpot-GC
date: 2018/9/12 19:37:00
updated: 
tag: 
- JVM
- GC
categories:
- Java


---
GC（垃圾收集；Garbage Collection）技术早于JAVA语言，随着技术的不断发展，如今内存分配与回收技术已经相当成熟。而学习JAVA的GC内容主要是为了在享受“自动化”的同时，实现对GC过程的监控和调节，分析解决内存溢出、内存泄漏等问题。

ps:本文主要针对HotSpot

<!-- more -->

# GC的原则

个人总结：

1. 必要性；能不进行回收就不进行回收（性能开销原因）。
2. 专用性：只能回收内存，无法回收句柄、数据库连接等
3. 不确定性：GC的时间时不确定的，即使主动调用GC也不能保证立马进行（安全点等因素）

# GC的区域

GC回收的主要区域是JAVA堆（GC最主要内存区域）、方法区（1.7及以前）或元空间（1.8）

* 为何**要关注**堆及方法区的垃圾收集？堆中内存分配是动态且不可知的。
* 为何**不关注**虚拟机栈等内存区域的垃圾收集？栈及程序计数器的内存分配随线程或方法一起创建及销毁，内存空间分配及回收是可确定的。

# GC的目标

## JAVA堆-对象

### 判断方法

根据**引用计数法**或**可达性分析法**，判断对象是否需被回收。

* 引用计数法：给对象添加引用计数器，每有一个引用则加1，引用失效则减1，为0则需被回收。优点：效率高、实现简单；缺点：难以解决循环引用问题。
* 可达性分析法：从GC-ROOT对象作为起点，向下搜索各个引用，若对象不可达（无引用链），则需被回收。  
&nbsp;&nbsp;&nbsp;&nbsp;GC-ROOT:可作为GC-ROOT的对象包含：1、虚拟机栈中引用的对象；2、方法区中静态属性引用的对象；3、方法区中常量引用的对象；4、Native方法引用的变量。  
&nbsp;&nbsp;&nbsp;&nbsp;引用链：从CG-ROOT出发搜索走过的路径。

### 引用类型

1. 强引用（Strong Reference）：不会被GC
2. 软引用（Soft Reference）：内存快溢出时回收
3. 弱引用（Weak Reference）：下次GC时回收
4. 虚引用（Phantom Reference）：回收时收到系统通知

### 回收过程

1. 对象不可达进行时，判断是否需执行finalize方法？不需要（无或者已执行）则进入“即将回收”集合：需要（未执行）则进入F-QUEUE。
2. F-QUEUE中的对象等待执行finalize方法（由专门的低优先级线程），虚拟机会触发该方法，但不保证方法执行完毕。
3. GC对F-QUEUE进行标记，若已执行且无引用则进入“即将回收”集合。
4. GC回收“即将回收”集合中的对象

ps：JVM只会主动触发一次对象的finalize方法（代码主动触发不计在内）
pps：不建议使用该方法

关于finalize更多资料可查看[java的finalize()函数](https://www.cnblogs.com/iamzhoug37/p/4279151.html)。

## 方法区-类

仅当方法区中的类满足以下3个条件时，可以被回收（不一定被回收）。

1. 当前类无任何实例
2. 该类的ClassLoader对象已被回收
3. 该类的Class对象没有被引用

# GC的方法

## 垃圾收集算法

### 标记-清除（Mark-Sweep）

* 分两阶段：标记-清除
* 基础算法
* 缺点：效率低，产生空间碎片

### 复制（Copying）

* 内存分块，其中一块使用完后，把存活对象复制到另一块，并清除当前内存块
* 优点：无内存空间碎片
* 缺点：内存损耗（必然有某个区域无法使用）

### 标记-整理（Mark-Compact）

* 标记，将存活的对象向内存的某一端移动，并清除存活对象边界外内存区域

### 分代收集（Generational Collection）

* 根据对象存活周期不同，将内存划分成几块，并采用相应的算法（上述算法的综合实现）

## 垃圾收集器

注：本部分所*并发*指其他其他用户线程可同时进行。未明确指出并发，则意味其他用户线程必须等待GC线程执行完毕。

### Serial

* 算法：复制算法（新生代） 标记-整理（老年代）
* 类型：单线程
* 特点：简单高效
* 缺点：STW时间长
* 应用场景：单核处理器、桌面应用

### ParNew

* 算法：复制算法（新生代） 标记-整理（老年代）
* 类型：多线程（新生代） 单线程（老年代）
* 特点：Serial升级版，可与CMS配合使用
* 缺点：存在线程交互的开销
* 应用场景：默认新生代收集器

### Parallel Scavenge

* 算法：复制算法
* 类型：多线程
* 特点：吞吐量（STW占用执行时间比例）可控、参数自适应
* 缺点：没有好的可配合使用的老年代收集器

### Serial Old

* Serial的老年代收集器
* 作为CMS的备选及以前与Parallel配合使用

### Parallel Old

* 区域：老年代
* 算法：标记-整理算法
* 类型：多线程
* 特点：吞吐量优先
* 应用场景：注重吞吐量及CPU敏感的场合

### CMS

* 区域：老年代
* 算法：标记-清除算法
* 特点：注重低回收停顿时间
* 应用场景：默认
* 过程：  
&nbsp;&nbsp;&nbsp;&nbsp;初始标记（单线程），可达标记
&nbsp;&nbsp;&nbsp;&nbsp;并发标记（单线程，并发），执行GC-ROOT Tracing
&nbsp;&nbsp;&nbsp;&nbsp;重新标记（多线程），修正因程序执行变动的对象
&nbsp;&nbsp;&nbsp;&nbsp;并发清除（单线程，并发）清除
* 缺点：1、CPU占用率高；2、无法清除浮动垃圾；3、产生空间碎片（碎片过多无法存放对向时，会提前触发FULL GC）

### G1

* 区域：堆划分的多个独立区域（Region）（新生代及老年代为Region的集合）
* 算法：标记-整理算法（整体而言） 复制算法（两个Region之间）
* 思想：化整数为零
* 特点：并发与并行、分代收集、空间整合、可预测的停顿
* 过程：  
&nbsp;&nbsp;&nbsp;&nbsp;初始标记（单线程）
&nbsp;&nbsp;&nbsp;&nbsp;并发标记（单线程，并发）
&nbsp;&nbsp;&nbsp;&nbsp;最终标记（多线程）
&nbsp;&nbsp;&nbsp;&nbsp;筛选回收（多线程）
（将耗时最长的并发标记与用户线程并发执行）

{% asset_img GCCLass.jpg 各GC收集器的类型及配合使用情况 %}

PS：针对G1的Region之间及其他垃圾回收器新生代和老年代之间对象的引用，为避免全堆扫描，会维护一个Remembered Set（G1中每个Refion都由各自的Set），在对引用类型数据进行操作时，判断对象是否在不同的区域中，若是，则通过CardTable把相关引用信息记录到Remembered Set中，并在GC时，把Remembered Set加入GC-Root即可。

---

# 对象内存分配策略

对象分配策略并非固定，与所用的垃圾收集器及虚拟机参数有关，一般而言，按照以下原则分配

## 优先分配Eden区

对象分配时，将优先分配到Eden区，若Eden区空间不足，会先发起一次Minor GC

## 大对象直接进入老年代

根据虚拟机参数，若对象为大对象，则直接进入老年代

## 长期存活对象进入老年代

默认年龄为15的对象（经过15次Minor GC）的对象将进入老年代

## 动态年龄判断

Survivor空间中相同年龄的对象所占空间总和大于Survivor的一半，则直接进入老年代。

## 空间分配担保

若开启空间分配担保，在Minor GC时，若servivor无法存放存活对象，则淬火对象直接进入老年代。若担保失败，会触发Full GC。

## Minor GC or Full GC

### Minor GC
1. 当Eden区满时，触发Minor GC。

### Full GC

1. 调用System.gc时，系统建议执行Full GC，但是不必然执行
2. 老年代空间不足
3. 方法区空间不足
4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存
5. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小

# HotSpot GC算法实现

## 枚举根节点（可达性分析实现）

问题：如何定位对象的哪些位置是引用？  

* 解决：使用一组OppMap的数据结构来获取对象引用的位置。  
* 原理：在类加载过程中，直接计算出大对象内什么偏移量上时什么数据类型；在JIT编译过程中，在特定位置记录栈和寄存器中哪些位置是引用。GC时即可得知对象引用信息

## 安全点（解决如何进入GC问题）

问题1：为每条指令创建OopMap，需要大量额外空间

* 解决：设置安全点（Safepoint），在特定位置才记录OopMap信息。
* 设置标准：是否具有让长时间执行的特征（即方法调用、循环跳转、异常跳转等）

问题2：多线程时如何让所以线程都到安全点

* 解决：
&nbsp;&nbsp;&nbsp;&nbsp;抢先式中断：先中断所有线程，若由线程不在安全点，则恢复该线程，并让其执行到安全点上。
&nbsp;&nbsp;&nbsp;&nbsp;主动式中断：设置一个标志，各个线程轮询，若需中断，则线程自己中断

## 安全区域（解决线程挂起等待行时无法到达安全点问题）

安全区域（Safe Region）指在一段代码片段中，引用关系不再发生变化。线程执行到安全区域时标识自己已经进入安全区域，在发起GC时，即可忽略进入安全区域的线程。



***

<small>2018-09-12 23:09    Cyalud    Xiamen</small>