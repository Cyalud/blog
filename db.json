{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/hipaper/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/comment.css","path":"css/comment.css","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/fashion.css","path":"css/fashion.css","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/glyphs.css","path":"css/glyphs.css","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/hipaper/source/js/insight.js","path":"js/insight.js","modified":0,"renderable":1},{"_id":"themes/hipaper/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/hipaper/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/hipaper/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/bootstrap.css","path":"css/bootstrap.css","modified":0,"renderable":1},{"_id":"themes/hipaper/source/js/bootstrap.js","path":"js/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/hipaper/source/js/jquery-3.1.1.min.js","path":"js/jquery-3.1.1.min.js","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/hipaper/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/fonts/athemes-glyphs.woff","path":"css/fonts/athemes-glyphs.woff","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/images/bg_1.jpg","path":"css/images/bg_1.jpg","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/images/favicon.ico","path":"css/images/favicon.ico","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/images/rocket.png","path":"css/images/rocket.png","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/hipaper/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/hipaper/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1522726648000},{"_id":"themes/hipaper/.travis.yml","hash":"24851843a40973daaee47b2697e8b0dc4e6556b3","modified":1522726648000},{"_id":"themes/hipaper/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1522726648000},{"_id":"themes/hipaper/LICENSE","hash":"e84291eaaeb4a02004d4aa6a504cbf9475f5c562","modified":1522726648000},{"_id":"themes/hipaper/_config.yml","hash":"422b83c4044b2d9cf5307c173d5d9476dd3bb886","modified":1536247144000},{"_id":"themes/hipaper/package.json","hash":"8cc069bbca0f14fdbad2be17fe3a6d1eda1ee581","modified":1522726648000},{"_id":"themes/hipaper/languages/default.yml","hash":"a7640a0c0c341fef694ed7367654cb5c2bde1af3","modified":1522726648000},{"_id":"themes/hipaper/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1522726648000},{"_id":"themes/hipaper/languages/en.yml","hash":"a7640a0c0c341fef694ed7367654cb5c2bde1af3","modified":1522726648000},{"_id":"themes/hipaper/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1522726648000},{"_id":"themes/hipaper/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1522726648000},{"_id":"themes/hipaper/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1522726648000},{"_id":"themes/hipaper/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1522726648000},{"_id":"themes/hipaper/languages/pt.yml","hash":"46bd5f121f4704e2cd6c0950ec18b549f03bfe5c","modified":1522726648000},{"_id":"themes/hipaper/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1522726648000},{"_id":"themes/hipaper/languages/zh-CN.yml","hash":"73c4a3d4ac3c5b89b096ed2cbea0dfce8586d2ad","modified":1522726648000},{"_id":"themes/hipaper/languages/zh-TW.yml","hash":"ea111659185c7d0d9d1add6da9f19fdce6a1cb9e","modified":1522726648000},{"_id":"themes/hipaper/layout/archive.ejs","hash":"bd3d87c361d3d0619516d2eaaf27d11b092b48a6","modified":1522726648000},{"_id":"themes/hipaper/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1536247394000},{"_id":"themes/hipaper/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1522726648000},{"_id":"themes/hipaper/layout/categories.ejs","hash":"05c63e56d49e80c08178728ad4552073e5f1c126","modified":1522726648000},{"_id":"themes/hipaper/layout/layout.ejs","hash":"beda9115367046f8b719c3b3ffb5bedb97f5d3c2","modified":1522726648000},{"_id":"themes/hipaper/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1522726648000},{"_id":"themes/hipaper/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1522726648000},{"_id":"themes/hipaper/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1522726648000},{"_id":"themes/hipaper/layout/tags.ejs","hash":"d98cb3bbc72dab15b1b518e30cfda58ef35c842e","modified":1522726648000},{"_id":"themes/hipaper/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1522726648000},{"_id":"source/_posts/2018-09-08-Markdown_basic.md","hash":"d12bbde224ccd3a563cf9306fa708cec50915c43","modified":1537066921608},{"_id":"source/_posts/2018-09-08-Nginx_install.md","hash":"b54ca507e899aa70a1786ed2a6581ec69174b681","modified":1537067102688},{"_id":"source/_posts/2018-09-11-JVM_BASIC_Memory.md","hash":"9d4f3670f011471b6c462b50507ab6e8e5de1fba","modified":1537067703788},{"_id":"source/_posts/2018-09-12-JVM_BASIC_GC.md","hash":"5d1b6675606343fdd4b80e97feda4637c46c0119","modified":1537067684432},{"_id":"source/_posts/2018-09-13-JVM_CLASS.md","hash":"9541523c8c5a1847a7f4f5d6e7fb4628b5bc84fb","modified":1537067694235},{"_id":"themes/hipaper/layout/_partial/after-footer.ejs","hash":"1ecf56b29969dab71727cee4ab81ac102b0f17b6","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/archive-post.ejs","hash":"29a9f178815ff7f9f1393d11afe016d7230a6b51","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/archive.ejs","hash":"ba641e2e4801bcc9df994d0596823af1982b5a00","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/article.ejs","hash":"60fed9db7894b2445c3a2c683b87e1ab463b0062","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/baidu-analytics.ejs","hash":"5776714a003d2b96b04b5399f67e0899d821247e","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/busuanzi-analytics.ejs","hash":"fd1eaae085c84733016737b11efe8e6b5b86ae63","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/cnzz-analytics.ejs","hash":"b0df992adf3c3c37189a66a98e6ef5ed06517ac4","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/comment.ejs","hash":"87bc07a72c95eeaff7f098fcb186c3ca1b1bc2ef","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/facebook-sdk.ejs","hash":"06038db50d2e1febdefa3f8e1512b332c7da5a17","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/footer.ejs","hash":"eac1d939826ecf3af4b2852500917e2e40e0ef21","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/head.ejs","hash":"016f344e5108d522cd012cebf7b9198f1104500d","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/header-post.ejs","hash":"b1af39790d209b5adff8757dcc97524e8fd0c60b","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/tencent-analytics.ejs","hash":"93120ad06c5d73ca777470faf570e993a805e049","modified":1522726648000},{"_id":"themes/hipaper/layout/_widget/archive.ejs","hash":"9fffde4e794b35f07c96eaec6d9373a40014da8f","modified":1522726648000},{"_id":"themes/hipaper/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1522726648000},{"_id":"themes/hipaper/layout/_widget/recent_posts.ejs","hash":"4ce0632c42a1aed974026c88ed945421e775695e","modified":1522726648000},{"_id":"themes/hipaper/layout/_widget/search.ejs","hash":"066b3e5f0abb4f6c91830bf910ee9c9ff8367ca1","modified":1522726648000},{"_id":"themes/hipaper/layout/_widget/social.ejs","hash":"875e82b6ae059e4f1d5627d29a00240182fe88a4","modified":1522726648000},{"_id":"themes/hipaper/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1522726648000},{"_id":"themes/hipaper/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1522726648000},{"_id":"themes/hipaper/layout/search/baidu.ejs","hash":"3e603a702d20c53fd3bcbeb570a16a86d54781ce","modified":1522726648000},{"_id":"themes/hipaper/layout/search/index-mobile.ejs","hash":"50a727ac1dfe3073eb6fa6699ba01e66f4ac41c0","modified":1522726648000},{"_id":"themes/hipaper/layout/search/index.ejs","hash":"a8e098693007fbf7ad7896bcf463b0ba3af1a4b7","modified":1522726648000},{"_id":"themes/hipaper/layout/search/insight.ejs","hash":"7d2a6d9639c08852345239d131784328ddf0493b","modified":1522726648000},{"_id":"themes/hipaper/layout/search/swiftype.ejs","hash":"379e66d2c13526e72e4120c443f95fccf4edef71","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1522726648000},{"_id":"themes/hipaper/source/css/_extend.styl","hash":"b099bbeb871790dbc9e1e48533a1f9a52c767506","modified":1522726648000},{"_id":"themes/hipaper/source/css/_variables.styl","hash":"6299e27a2f5bb838f55fd756b74590b147aa1638","modified":1522726648000},{"_id":"themes/hipaper/source/css/comment.css","hash":"0f0d50e4153ce92b22ee18b214dfc76d8c386376","modified":1522726648000},{"_id":"themes/hipaper/source/css/fashion.css","hash":"3870e1ee8c850e92d9c3aa71d03afa7b0eef2a5c","modified":1522726648000},{"_id":"themes/hipaper/source/css/glyphs.css","hash":"c4088f9a347e42a31d9aabc8aa17ead3d1ed8b8e","modified":1522726648000},{"_id":"themes/hipaper/source/css/style.styl","hash":"68118d98ad5fa1b2e1b0dc83a96782711735ffe9","modified":1522726648000},{"_id":"themes/hipaper/source/js/insight.js","hash":"2995f3f94d0a9887b08e38a6f5053b6ca2997c19","modified":1522726648000},{"_id":"themes/hipaper/source/js/main.js","hash":"0c4ab8de5dd6a6733f0095036a90f5fff61c2261","modified":1522726648000},{"_id":"themes/hipaper/source/js/script.js","hash":"4964e125255a3f1afbf05728b331ad1fb1646e4d","modified":1522726648000},{"_id":"themes/hipaper/source/js/totop.js","hash":"560baaa7bbf70ce67261b39aef61293646d9e539","modified":1522726648000},{"_id":"source/_posts/2018-09-08-Markdown_basic/googlelogo.png","hash":"1737d3dfb411c07b86ed8bd30f5987a4dc397cc1","modified":1536335550000},{"_id":"source/_posts/2018-09-11-JVM_BASIC_Memory/DirectBuffer.png","hash":"0ed2e81e1e3c5ae78da5f80307084972cb9d0d2f","modified":1536679356161},{"_id":"source/_posts/2018-09-12-JVM_GC/GCCLass.jpg","hash":"4868a7828d4aedd91bbc71f132c183cfb9743a85","modified":1536764541001},{"_id":"themes/hipaper/source/css/_partial/header.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1522726648000},{"_id":"themes/hipaper/source/css/_partial/footer.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1522726648000},{"_id":"themes/hipaper/source/css/_partial/header-post.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1522726648000},{"_id":"themes/hipaper/source/css/bootstrap.css","hash":"afa4ed6bce62b265d08b0a5011558fe63e0bd289","modified":1522726648000},{"_id":"themes/hipaper/source/js/bootstrap.js","hash":"3b965a36a6b08854ad6eddedf85c5319fd392b4a","modified":1522726648000},{"_id":"themes/hipaper/source/js/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/post/busuanzi-analytics.ejs","hash":"125fcedc8baf7dc67587c2ded05bfa8df868989a","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/post/category.ejs","hash":"7d167be432a0f41034f7e34ea33eb8748202358d","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/post/date.ejs","hash":"fe3cf76bb84d85112997320628d87f024b5e3a45","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/post/mathjax.ejs","hash":"571c19f57c2b38ac5cd9b8f811cfad53b38616cf","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/post/gallery.ejs","hash":"30028f10a4f03561e53da323d06b292e1ae7990c","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/post/tag.ejs","hash":"e6ab2d49029ed4b15204f84928b14b036a0c9c84","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/post/title.ejs","hash":"a61267f27f2148321e549344be91dbc4e22e1a48","modified":1522726648000},{"_id":"themes/hipaper/layout/_partial/post/urlconvert.ejs","hash":"2133f1029632417f9043b9d4749d580ed0c75db0","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1522726648000},{"_id":"themes/hipaper/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1522726648000},{"_id":"themes/hipaper/source/css/_partial/archive.styl","hash":"a5465e8a1f9969a14c6fb649d6443775c969b612","modified":1522726648000},{"_id":"themes/hipaper/source/css/_partial/article.styl","hash":"7b3835c3c8ddfce801014cd7288182e8d587f450","modified":1522726648000},{"_id":"themes/hipaper/source/css/_partial/comment.styl","hash":"f23dbf9c1224559314f7d10b7fee030a9ffab58a","modified":1522726648000},{"_id":"themes/hipaper/source/css/_partial/highlight.styl","hash":"81d4b4431ad4ffff6937ac3b78f0effecd92b553","modified":1522726648000},{"_id":"themes/hipaper/source/css/_partial/insight.styl","hash":"6da7629c668d7bcfbd527265906927e34b5043d5","modified":1522726648000},{"_id":"themes/hipaper/source/css/_partial/mobile.styl","hash":"fcfbaf24634519063af46953e0eb733a8ada5556","modified":1522726648000},{"_id":"themes/hipaper/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1522726648000},{"_id":"themes/hipaper/source/css/_partial/sidebar-aside.styl","hash":"a4f67e98dc244ba6119da065e69bcaf1a9066b94","modified":1522726648000},{"_id":"themes/hipaper/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1522726648000},{"_id":"themes/hipaper/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1522726648000},{"_id":"themes/hipaper/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1522726648000},{"_id":"themes/hipaper/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1522726648000},{"_id":"themes/hipaper/source/css/fonts/athemes-glyphs.woff","hash":"f1ac9ffcc97571ceff48b68792c34de97bc289c0","modified":1522726648000},{"_id":"themes/hipaper/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1522726648000},{"_id":"themes/hipaper/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1522726648000},{"_id":"themes/hipaper/source/css/images/bg_1.jpg","hash":"8ca488e85d23134b8b6307b78f4c3ed864b6e5b1","modified":1536243628000},{"_id":"themes/hipaper/source/css/images/favicon.ico","hash":"8b3d31f989ecea018651b8048244622df487a8db","modified":1536245316000},{"_id":"themes/hipaper/source/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1522726648000},{"_id":"source/_posts/2018-09-11-JVM_BASIC_Memory/RuntimeMemory.png","hash":"09ec4af7b09aa9a4686d2519a1999f73dbba64d9","modified":1536670296871},{"_id":"themes/hipaper/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1522726648000},{"_id":"themes/hipaper/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1522726648000},{"_id":"public/tags/markdown/index.html","hash":"1575567d9f62a69d523a63937ea52378affa3d32","modified":1537068629302},{"_id":"public/tags/Synopsis/index.html","hash":"d2dc6d0bca2e12af994faa6a6c1a42847fe569cb","modified":1537068629302},{"_id":"public/tags/install/index.html","hash":"c896ed91a57ba843c620d03c2c2aa8e1c7b93fb5","modified":1537068629302},{"_id":"public/tags/GC/index.html","hash":"91085231f4f481e6840f04bb0ed73715db27d47e","modified":1537068629303},{"_id":"public/tags/内存分配/index.html","hash":"81d29608ce5d49d2b06bc5ad7a152318ef14ea9a","modified":1537068629303},{"_id":"public/tags/字节码/index.html","hash":"0a0db36b83c3f796b4ef5a087c6e294eeab906fd","modified":1537068629303},{"_id":"public/categories/hexo/index.html","hash":"dba14504a69e754f5fe806f3b707e4a21484ea8b","modified":1537068629303},{"_id":"public/categories/nginx/index.html","hash":"a3676376093c36b0237806cdd12a4e1958c6d014","modified":1537068629303},{"_id":"public/2018/09/13/2018-09-13-JVM_CLASS/index.html","hash":"18c9407b772b7a956c7bbe3ddb082a97945505ec","modified":1537068629303},{"_id":"public/2018/09/12/2018-09-12-JVM_BASIC_GC/index.html","hash":"194337f4401bc6bfbad71c7bf7d621d809ad8a26","modified":1537068629304},{"_id":"public/2018/09/11/2018-09-11-JVM_BASIC_Memory/index.html","hash":"75fb3a4be414849049675df55d507811cf04a99a","modified":1537068629304},{"_id":"public/2018/09/08/2018-09-08-Nginx_install/index.html","hash":"ae09cf18834a4fb758475e2e0de1a878647e74f9","modified":1537068629304},{"_id":"public/archives/index.html","hash":"f45da1c32069e5b0d613bd3b422b56efec9ab26d","modified":1537068629304},{"_id":"public/archives/2018/index.html","hash":"ae041e8184d9b274b84d83ddb567733177a49128","modified":1537068629304},{"_id":"public/archives/2018/09/index.html","hash":"6dfd2762321e7942e88edbc88dc114fa132e0a9f","modified":1537068629304},{"_id":"public/index.html","hash":"e3c9fef154c7843a175bb6b9cfcccd71a3b9dc54","modified":1537068629304},{"_id":"public/categories/Java/index.html","hash":"2d14f84f575189b1cd5d12fa95f2aec641f8e726","modified":1537068629303},{"_id":"public/2018/09/08/2018-09-08-Markdown_basic/index.html","hash":"7f59f7d605d2a0ca46cd8dd9dac392cd0cddd16a","modified":1537068629304},{"_id":"public/categories/Java/JVM/index.html","hash":"1893085cc622c2624fd2a084fd72b8d0cec40c32","modified":1537067343196},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1537068004804},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1537068004804},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1537068004804},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1537068004804},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1537068004804},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1537068004804},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1537068004804},{"_id":"public/css/fonts/athemes-glyphs.woff","hash":"f1ac9ffcc97571ceff48b68792c34de97bc289c0","modified":1537068004804},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1537068004805},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1537068004805},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1537068004804},{"_id":"public/css/images/favicon.ico","hash":"8b3d31f989ecea018651b8048244622df487a8db","modified":1537068004805},{"_id":"public/css/images/bg_1.jpg","hash":"8ca488e85d23134b8b6307b78f4c3ed864b6e5b1","modified":1537068004805},{"_id":"public/css/images/rocket.png","hash":"6dee0406955aa9b7a261161d30f2538a671e806b","modified":1537068004805},{"_id":"public/2018/09/08/2018-09-08-Markdown_basic/googlelogo.png","hash":"1737d3dfb411c07b86ed8bd30f5987a4dc397cc1","modified":1537068004805},{"_id":"public/2018/09/11/2018-09-11-JVM_BASIC_Memory/DirectBuffer.png","hash":"0ed2e81e1e3c5ae78da5f80307084972cb9d0d2f","modified":1537068004805},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1537068005186},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1537068005191},{"_id":"public/css/comment.css","hash":"0f0d50e4153ce92b22ee18b214dfc76d8c386376","modified":1537068005191},{"_id":"public/css/glyphs.css","hash":"c4088f9a347e42a31d9aabc8aa17ead3d1ed8b8e","modified":1537068005191},{"_id":"public/js/main.js","hash":"0c4ab8de5dd6a6733f0095036a90f5fff61c2261","modified":1537068005192},{"_id":"public/js/insight.js","hash":"2995f3f94d0a9887b08e38a6f5053b6ca2997c19","modified":1537068005192},{"_id":"public/js/script.js","hash":"4964e125255a3f1afbf05728b331ad1fb1646e4d","modified":1537068005192},{"_id":"public/js/totop.js","hash":"560baaa7bbf70ce67261b39aef61293646d9e539","modified":1537068005192},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1537068005192},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1537068005192},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1537068005192},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1537068005192},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1537068005192},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1537068005192},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1537068005192},{"_id":"public/css/style.css","hash":"e94b6580cea482655a606899670cc3fb4e2528bc","modified":1537068005193},{"_id":"public/css/fashion.css","hash":"3870e1ee8c850e92d9c3aa71d03afa7b0eef2a5c","modified":1537068005192},{"_id":"public/js/bootstrap.js","hash":"3b965a36a6b08854ad6eddedf85c5319fd392b4a","modified":1537068005193},{"_id":"public/js/jquery-3.1.1.min.js","hash":"f647a6d37dc4ca055ced3cf64bbc1f490070acba","modified":1537068005193},{"_id":"public/css/bootstrap.css","hash":"afa4ed6bce62b265d08b0a5011558fe63e0bd289","modified":1537068005193},{"_id":"public/2018/09/11/2018-09-11-JVM_BASIC_Memory/RuntimeMemory.png","hash":"09ec4af7b09aa9a4686d2519a1999f73dbba64d9","modified":1537068005193},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1537068005195},{"_id":"source/categories/index.md","hash":"e61185e0304fa3e307eced0d96ac1017784955eb","modified":1536205666000},{"_id":"source/tags/index.md","hash":"534fc1ffbc7a7d2d8694fd51a30e963f77e04a35","modified":1536239362000},{"_id":"source/about/index.md","hash":"5ad7b21ca356ce8e557bdba79af1ab8b99cdefa6","modified":1536241142000},{"_id":"public/about/index.html","hash":"387d20a88a459af5eb582f275346c088f2ac25f5","modified":1537068629302},{"_id":"public/categories/index.html","hash":"2bd746b91e924d4882ec714a06111821672303e1","modified":1537068629303},{"_id":"public/tags/index.html","hash":"fa1c7c1286fb5d0e135fcdb583f5f572efa339e3","modified":1537068629303},{"_id":"public/tags/JVM/index.html","hash":"340dcc197914393b34d2b04e9bc017f5d348272e","modified":1537068629303}],"Category":[{"name":"hexo","_id":"cjm4a7k3l0002dwvjzvag6yzi"},{"name":"nginx","_id":"cjm4a7k3q0007dwvjfuggxwed"},{"name":"Java","_id":"cjm4a7k3s000adwvjrl60erkt"},{"name":"JVM","parent":"cjm4a7k3s000adwvjrl60erkt","_id":"cjm4a7k3x000ldwvjm22qj0t5"}],"Data":[],"Page":[{"title":"categories","date":"2018-09-06T03:45:11.000Z","layout":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-09-06 11:45:11\nlayout: \"categories\"\n---\n","updated":"2018-09-06T03:47:46.000Z","path":"categories/index.html","comments":1,"_id":"cjm4abtby00006svj75yddq3i","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-09-06T09:14:00.000Z","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-09-06 17:14:00\nlayout: \"tags\"\ncomments: false\n---\n","updated":"2018-09-06T13:09:22.000Z","path":"tags/index.html","_id":"cjm4abtc000016svjx8szdd6y","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"about","date":"2018-09-06T09:14:07.000Z","layout":"about","comments":0,"_content":"","source":"about/index.md","raw":"---\ntitle: about\ndate: 2018-09-06 17:14:07\nlayout: \"about\"\ncomments: false\n---\n","updated":"2018-09-06T13:39:02.000Z","path":"about/index.html","_id":"cjm4abtcf00026svjdmq3y10f","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"markdown基础篇","date":"2018-09-08T00:15:25.000Z","updated":"2018-09-08T13:34:25.000Z","_content":"ps：markdown没有标准化，以下内容主要针对Hexo相关语法。\n<!-- more -->\n\n# What\n\n纯文本-标记语言\n\n# Why\n\n简单直观\n（语法简单，快速编写，直接阅读）\n\n# Why not\n\n简单\n（语法记忆，样式简单）\n\n# How\n\n## 标题\n\n    # 一级标题\n    ## 二级标题\n    ### 三级标题\n    #### 四级标题\n    ##### 五级标题\n    ###### 六级标题\n\n\nps：最多支持6级\npps：标准语法中，#后面需带空格；\n\n## 字体\n\n    1、**加粗**\n    2、*斜体*\n    3、***斜体加粗***\n    4、~~删除线~~\n\n效果对应如下：\n1、**加粗** \n2、*斜体*\n3、***斜体加粗***\n4、~~删除线~~\nps：标准语法中，可用_替换*，效果一致。\n\n## 引用\n\n\t>这是一级引用\n\t>>这是二级引用\n\t>>>这是三级引用\n\t\n效果如下：\n\n>这是一级引用\n>>这是二级引用\n>>>这是三级引用\n\n\nps：貌似可以引用层级没有上限，但是从效果上，不建议使用特别多级的引用。\n\n## 代码块\n\n每行开始加上4个空格或一个制表符即表示代码块。代码块中可用来高亮显示。\n\n效果：\n\n\tpublic static void main(String[] args) \n\t{ \n\t\tSystem.out.println(“Hello, Word.”); \n\t} \n\t\n## 链接\n\n常用：\n\n\t[google](https://www.google.com/)\n\t<https://www.baidu.com>\n\t\n效果：\n\n[google](https://www.google.com/)\n<https://www.baidu.com>\n\n\n进阶用法：\n\n\t[谷歌][1]\n\t[百度][baidu]\n\n\t[1]: https://www.google.com/\n\t[baidu]: https://www.baidu.com/\n\n效果：\n\n[谷歌][1]\n[百度][baidu]\n\n[1]:https://www.google.com/\n[baidu]:https://www.baidu.com/\n\nps：标注前一定要有空行，标注前一定要有空行，标注前一定要有空行。\n\n## 图片\n\n网络图片：\n\n\t![baidu](https://www.baidu.com/img/bd_logo1.png)\t\n\t\n\t![baidu][2]\n\n\t[2]:https://www.baidu.com/img/bd_logo1.png\n\n效果：\n\n![baidu](https://www.baidu.com/img/bd_logo1.png)\n![baidu][2]\n\n[2]:https://www.baidu.com/img/bd_logo1.png\n\n\n## 列表\n\n无序列表：\n\n\t+ 加号无序列表1\n\t+ 加号无序列表2\n\n\t- 减号无序列表1\n\t- 减号无序列表2\n\t\n\t* 星号无序列表1\n\t* 星号无序列表2\n\n效果：\n\n+ 加号无序列表1\n+ 加号无序列表2\n\n- 减号无序列表1\n- 减号无序列表2\n\n* 星号无序列表1\n* 星号无序列表2\n\n有序列表：\n\n\t1. 有序列表1\n\t2. 有序列表2\n\t7. 有序列表3\n\t\n效果：\n\n1. 有序列表1\n2. 有序列表2\n7. 有序列表3\n\nps：如上，有序列表会自动更正序号。\n\n## 表格\n\n\t| 表头1    | 表头2  | 表头3  |\n\t|:---------|:------:|-------:|\n\t| 类型A     | A      |B       |\n\t| 类型B     | C      |D       |\n\n效果：\n\n| 表头1    | 表头2  | 表头3  |\n|:---------|:------:|-------:|\n| 类型A     | A      |B       |\n| 类型B     | C      |D       |\n\n几点说明：\n1、表格列宽自动分配，类似于table-layout:automatic\n2、第二行为列的对其属性,用`:`来表示对齐，`:-:`为居中，不加为居中\n\n## 其他\n\n### 分割线\n\n\t***\n\n\t---\n\n效果：\n\n***\n\n---\n\n### 标记\n\t\n\t`mark`\n\n效果：\n\n`mark`\n\n***\n\n## 附录 特殊字符\n\n\t! \t&#33;\n\t” \t&#34; &quot; \n\t# \t&#35; \n\t$ \t&#36;\n\t% \t&#37; \n\t& \t&#38; &amp; \n\t‘ \t&#39; \n\t( \t&#40;  \n\t) \t&#41; \n\t*   &#42; \n\t+   &#43;\n\t< \t&#60; &lt;\n\t= \t&#61; \n\t>   &#62; &gt; \n\t?   &#63;\n\t@   &#64;\n\t[   &#91;\n\t\\   &#92;\n\t]   &#93;\n\t{   &#123;\n\t|   &#124;\n\t}   &#125;\n","source":"_posts/2018-09-08-Markdown_basic.md","raw":"---\ntitle: markdown基础篇\ndate: 2018/9/8 8:15:25\nupdated: 2018/9/8 21:34:25\ntag: \n- markdown\n- Synopsis\ncategories:\n- hexo\n\n---\nps：markdown没有标准化，以下内容主要针对Hexo相关语法。\n<!-- more -->\n\n# What\n\n纯文本-标记语言\n\n# Why\n\n简单直观\n（语法简单，快速编写，直接阅读）\n\n# Why not\n\n简单\n（语法记忆，样式简单）\n\n# How\n\n## 标题\n\n    # 一级标题\n    ## 二级标题\n    ### 三级标题\n    #### 四级标题\n    ##### 五级标题\n    ###### 六级标题\n\n\nps：最多支持6级\npps：标准语法中，#后面需带空格；\n\n## 字体\n\n    1、**加粗**\n    2、*斜体*\n    3、***斜体加粗***\n    4、~~删除线~~\n\n效果对应如下：\n1、**加粗** \n2、*斜体*\n3、***斜体加粗***\n4、~~删除线~~\nps：标准语法中，可用_替换*，效果一致。\n\n## 引用\n\n\t>这是一级引用\n\t>>这是二级引用\n\t>>>这是三级引用\n\t\n效果如下：\n\n>这是一级引用\n>>这是二级引用\n>>>这是三级引用\n\n\nps：貌似可以引用层级没有上限，但是从效果上，不建议使用特别多级的引用。\n\n## 代码块\n\n每行开始加上4个空格或一个制表符即表示代码块。代码块中可用来高亮显示。\n\n效果：\n\n\tpublic static void main(String[] args) \n\t{ \n\t\tSystem.out.println(“Hello, Word.”); \n\t} \n\t\n## 链接\n\n常用：\n\n\t[google](https://www.google.com/)\n\t<https://www.baidu.com>\n\t\n效果：\n\n[google](https://www.google.com/)\n<https://www.baidu.com>\n\n\n进阶用法：\n\n\t[谷歌][1]\n\t[百度][baidu]\n\n\t[1]: https://www.google.com/\n\t[baidu]: https://www.baidu.com/\n\n效果：\n\n[谷歌][1]\n[百度][baidu]\n\n[1]:https://www.google.com/\n[baidu]:https://www.baidu.com/\n\nps：标注前一定要有空行，标注前一定要有空行，标注前一定要有空行。\n\n## 图片\n\n网络图片：\n\n\t![baidu](https://www.baidu.com/img/bd_logo1.png)\t\n\t\n\t![baidu][2]\n\n\t[2]:https://www.baidu.com/img/bd_logo1.png\n\n效果：\n\n![baidu](https://www.baidu.com/img/bd_logo1.png)\n![baidu][2]\n\n[2]:https://www.baidu.com/img/bd_logo1.png\n\n\n## 列表\n\n无序列表：\n\n\t+ 加号无序列表1\n\t+ 加号无序列表2\n\n\t- 减号无序列表1\n\t- 减号无序列表2\n\t\n\t* 星号无序列表1\n\t* 星号无序列表2\n\n效果：\n\n+ 加号无序列表1\n+ 加号无序列表2\n\n- 减号无序列表1\n- 减号无序列表2\n\n* 星号无序列表1\n* 星号无序列表2\n\n有序列表：\n\n\t1. 有序列表1\n\t2. 有序列表2\n\t7. 有序列表3\n\t\n效果：\n\n1. 有序列表1\n2. 有序列表2\n7. 有序列表3\n\nps：如上，有序列表会自动更正序号。\n\n## 表格\n\n\t| 表头1    | 表头2  | 表头3  |\n\t|:---------|:------:|-------:|\n\t| 类型A     | A      |B       |\n\t| 类型B     | C      |D       |\n\n效果：\n\n| 表头1    | 表头2  | 表头3  |\n|:---------|:------:|-------:|\n| 类型A     | A      |B       |\n| 类型B     | C      |D       |\n\n几点说明：\n1、表格列宽自动分配，类似于table-layout:automatic\n2、第二行为列的对其属性,用`:`来表示对齐，`:-:`为居中，不加为居中\n\n## 其他\n\n### 分割线\n\n\t***\n\n\t---\n\n效果：\n\n***\n\n---\n\n### 标记\n\t\n\t`mark`\n\n效果：\n\n`mark`\n\n***\n\n## 附录 特殊字符\n\n\t! \t&#33;\n\t” \t&#34; &quot; \n\t# \t&#35; \n\t$ \t&#36;\n\t% \t&#37; \n\t& \t&#38; &amp; \n\t‘ \t&#39; \n\t( \t&#40;  \n\t) \t&#41; \n\t*   &#42; \n\t+   &#43;\n\t< \t&#60; &lt;\n\t= \t&#61; \n\t>   &#62; &gt; \n\t?   &#63;\n\t@   &#64;\n\t[   &#91;\n\t\\   &#92;\n\t]   &#93;\n\t{   &#123;\n\t|   &#124;\n\t}   &#125;\n","slug":"2018-09-08-Markdown_basic","published":1,"comments":1,"layout":"post","photos":[],"link":"","_id":"cjm4a7k3f0000dwvj2srpthyz","content":"<p>ps：markdown没有标准化，以下内容主要针对Hexo相关语法。<br><a id=\"more\"></a></p>\n<h1 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h1><p>纯文本-标记语言</p>\n<h1 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h1><p>简单直观<br>（语法简单，快速编写，直接阅读）</p>\n<h1 id=\"Why-not\"><a href=\"#Why-not\" class=\"headerlink\" title=\"Why not\"></a>Why not</h1><p>简单<br>（语法记忆，样式简单）</p>\n<h1 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h1><h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><pre><code># 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n</code></pre><p>ps：最多支持6级<br>pps：标准语法中，#后面需带空格；</p>\n<h2 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h2><pre><code>1、**加粗**\n2、*斜体*\n3、***斜体加粗***\n4、~~删除线~~\n</code></pre><p>效果对应如下：<br>1、<strong>加粗</strong><br>2、<em>斜体</em><br>3、<strong><em>斜体加粗</em></strong><br>4、<del>删除线</del><br>ps：标准语法中，可用_替换*，效果一致。</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><pre><code>&gt;这是一级引用\n&gt;&gt;这是二级引用\n&gt;&gt;&gt;这是三级引用\n</code></pre><p>效果如下：</p>\n<blockquote>\n<p>这是一级引用</p>\n<blockquote>\n<p>这是二级引用</p>\n<blockquote>\n<p>这是三级引用</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>ps：貌似可以引用层级没有上限，但是从效果上，不建议使用特别多级的引用。</p>\n<h2 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h2><p>每行开始加上4个空格或一个制表符即表示代码块。代码块中可用来高亮显示。</p>\n<p>效果：</p>\n<pre><code>public static void main(String[] args) \n{ \n    System.out.println(“Hello, Word.”); \n} \n</code></pre><h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>常用：</p>\n<pre><code>[google](https://www.google.com/)\n&lt;https://www.baidu.com&gt;\n</code></pre><p>效果：</p>\n<p><a href=\"https://www.google.com/\" target=\"_blank\" rel=\"noopener\">google</a><br><a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com</a></p>\n<p>进阶用法：</p>\n<pre><code>[谷歌][1]\n[百度][baidu]\n\n[1]: https://www.google.com/\n[baidu]: https://www.baidu.com/\n</code></pre><p>效果：</p>\n<p><a href=\"https://www.google.com/\" target=\"_blank\" rel=\"noopener\">谷歌</a><br><a href=\"https://www.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度</a></p>\n<p>ps：标注前一定要有空行，标注前一定要有空行，标注前一定要有空行。</p>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>网络图片：</p>\n<pre><code>![baidu](https://www.baidu.com/img/bd_logo1.png)    \n\n![baidu][2]\n\n[2]:https://www.baidu.com/img/bd_logo1.png\n</code></pre><p>效果：</p>\n<p><img src=\"https://www.baidu.com/img/bd_logo1.png\" alt=\"baidu\"><br><img src=\"https://www.baidu.com/img/bd_logo1.png\" alt=\"baidu\"></p>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><p>无序列表：</p>\n<pre><code>+ 加号无序列表1\n+ 加号无序列表2\n\n- 减号无序列表1\n- 减号无序列表2\n\n* 星号无序列表1\n* 星号无序列表2\n</code></pre><p>效果：</p>\n<ul>\n<li>加号无序列表1</li>\n<li>加号无序列表2</li>\n</ul>\n<ul>\n<li>减号无序列表1</li>\n<li>减号无序列表2</li>\n</ul>\n<ul>\n<li>星号无序列表1</li>\n<li>星号无序列表2</li>\n</ul>\n<p>有序列表：</p>\n<pre><code>1. 有序列表1\n2. 有序列表2\n7. 有序列表3\n</code></pre><p>效果：</p>\n<ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n<li>有序列表3</li>\n</ol>\n<p>ps：如上，有序列表会自动更正序号。</p>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><pre><code>| 表头1    | 表头2  | 表头3  |\n|:---------|:------:|-------:|\n| 类型A     | A      |B       |\n| 类型B     | C      |D       |\n</code></pre><p>效果：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">表头1</th>\n<th style=\"text-align:center\">表头2</th>\n<th style=\"text-align:right\">表头3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">类型A</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:right\">B</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">类型B</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:right\">D</td>\n</tr>\n</tbody>\n</table>\n<p>几点说明：<br>1、表格列宽自动分配，类似于table-layout:automatic<br>2、第二行为列的对其属性,用<code>:</code>来表示对齐，<code>:-:</code>为居中，不加为居中</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h3><pre><code>***\n\n---\n</code></pre><p>效果：</p>\n<hr>\n<hr>\n<h3 id=\"标记\"><a href=\"#标记\" class=\"headerlink\" title=\"标记\"></a>标记</h3><pre><code>`mark`\n</code></pre><p>效果：</p>\n<p><code>mark</code></p>\n<hr>\n<h2 id=\"附录-特殊字符\"><a href=\"#附录-特殊字符\" class=\"headerlink\" title=\"附录 特殊字符\"></a>附录 特殊字符</h2><pre><code>!     &amp;#33;\n”     &amp;#34; &amp;quot; \n#     &amp;#35; \n$     &amp;#36;\n%     &amp;#37; \n&amp;     &amp;#38; &amp;amp; \n‘     &amp;#39; \n(     &amp;#40;  \n)     &amp;#41; \n*   &amp;#42; \n+   &amp;#43;\n&lt;     &amp;#60; &amp;lt;\n=     &amp;#61; \n&gt;   &amp;#62; &amp;gt; \n?   &amp;#63;\n@   &amp;#64;\n[   &amp;#91;\n\\   &amp;#92;\n]   &amp;#93;\n{   &amp;#123;\n|   &amp;#124;\n}   &amp;#125;\n</code></pre>","site":{"data":{}},"excerpt":"<p>ps：markdown没有标准化，以下内容主要针对Hexo相关语法。<br>","more":"</p>\n<h1 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h1><p>纯文本-标记语言</p>\n<h1 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h1><p>简单直观<br>（语法简单，快速编写，直接阅读）</p>\n<h1 id=\"Why-not\"><a href=\"#Why-not\" class=\"headerlink\" title=\"Why not\"></a>Why not</h1><p>简单<br>（语法记忆，样式简单）</p>\n<h1 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h1><h2 id=\"标题\"><a href=\"#标题\" class=\"headerlink\" title=\"标题\"></a>标题</h2><pre><code># 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n</code></pre><p>ps：最多支持6级<br>pps：标准语法中，#后面需带空格；</p>\n<h2 id=\"字体\"><a href=\"#字体\" class=\"headerlink\" title=\"字体\"></a>字体</h2><pre><code>1、**加粗**\n2、*斜体*\n3、***斜体加粗***\n4、~~删除线~~\n</code></pre><p>效果对应如下：<br>1、<strong>加粗</strong><br>2、<em>斜体</em><br>3、<strong><em>斜体加粗</em></strong><br>4、<del>删除线</del><br>ps：标准语法中，可用_替换*，效果一致。</p>\n<h2 id=\"引用\"><a href=\"#引用\" class=\"headerlink\" title=\"引用\"></a>引用</h2><pre><code>&gt;这是一级引用\n&gt;&gt;这是二级引用\n&gt;&gt;&gt;这是三级引用\n</code></pre><p>效果如下：</p>\n<blockquote>\n<p>这是一级引用</p>\n<blockquote>\n<p>这是二级引用</p>\n<blockquote>\n<p>这是三级引用</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>ps：貌似可以引用层级没有上限，但是从效果上，不建议使用特别多级的引用。</p>\n<h2 id=\"代码块\"><a href=\"#代码块\" class=\"headerlink\" title=\"代码块\"></a>代码块</h2><p>每行开始加上4个空格或一个制表符即表示代码块。代码块中可用来高亮显示。</p>\n<p>效果：</p>\n<pre><code>public static void main(String[] args) \n{ \n    System.out.println(“Hello, Word.”); \n} \n</code></pre><h2 id=\"链接\"><a href=\"#链接\" class=\"headerlink\" title=\"链接\"></a>链接</h2><p>常用：</p>\n<pre><code>[google](https://www.google.com/)\n&lt;https://www.baidu.com&gt;\n</code></pre><p>效果：</p>\n<p><a href=\"https://www.google.com/\" target=\"_blank\" rel=\"noopener\">google</a><br><a href=\"https://www.baidu.com\" target=\"_blank\" rel=\"noopener\">https://www.baidu.com</a></p>\n<p>进阶用法：</p>\n<pre><code>[谷歌][1]\n[百度][baidu]\n\n[1]: https://www.google.com/\n[baidu]: https://www.baidu.com/\n</code></pre><p>效果：</p>\n<p><a href=\"https://www.google.com/\" target=\"_blank\" rel=\"noopener\">谷歌</a><br><a href=\"https://www.baidu.com/\" target=\"_blank\" rel=\"noopener\">百度</a></p>\n<p>ps：标注前一定要有空行，标注前一定要有空行，标注前一定要有空行。</p>\n<h2 id=\"图片\"><a href=\"#图片\" class=\"headerlink\" title=\"图片\"></a>图片</h2><p>网络图片：</p>\n<pre><code>![baidu](https://www.baidu.com/img/bd_logo1.png)    \n\n![baidu][2]\n\n[2]:https://www.baidu.com/img/bd_logo1.png\n</code></pre><p>效果：</p>\n<p><img src=\"https://www.baidu.com/img/bd_logo1.png\" alt=\"baidu\"><br><img src=\"https://www.baidu.com/img/bd_logo1.png\" alt=\"baidu\"></p>\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><p>无序列表：</p>\n<pre><code>+ 加号无序列表1\n+ 加号无序列表2\n\n- 减号无序列表1\n- 减号无序列表2\n\n* 星号无序列表1\n* 星号无序列表2\n</code></pre><p>效果：</p>\n<ul>\n<li>加号无序列表1</li>\n<li>加号无序列表2</li>\n</ul>\n<ul>\n<li>减号无序列表1</li>\n<li>减号无序列表2</li>\n</ul>\n<ul>\n<li>星号无序列表1</li>\n<li>星号无序列表2</li>\n</ul>\n<p>有序列表：</p>\n<pre><code>1. 有序列表1\n2. 有序列表2\n7. 有序列表3\n</code></pre><p>效果：</p>\n<ol>\n<li>有序列表1</li>\n<li>有序列表2</li>\n<li>有序列表3</li>\n</ol>\n<p>ps：如上，有序列表会自动更正序号。</p>\n<h2 id=\"表格\"><a href=\"#表格\" class=\"headerlink\" title=\"表格\"></a>表格</h2><pre><code>| 表头1    | 表头2  | 表头3  |\n|:---------|:------:|-------:|\n| 类型A     | A      |B       |\n| 类型B     | C      |D       |\n</code></pre><p>效果：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">表头1</th>\n<th style=\"text-align:center\">表头2</th>\n<th style=\"text-align:right\">表头3</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">类型A</td>\n<td style=\"text-align:center\">A</td>\n<td style=\"text-align:right\">B</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">类型B</td>\n<td style=\"text-align:center\">C</td>\n<td style=\"text-align:right\">D</td>\n</tr>\n</tbody>\n</table>\n<p>几点说明：<br>1、表格列宽自动分配，类似于table-layout:automatic<br>2、第二行为列的对其属性,用<code>:</code>来表示对齐，<code>:-:</code>为居中，不加为居中</p>\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h3 id=\"分割线\"><a href=\"#分割线\" class=\"headerlink\" title=\"分割线\"></a>分割线</h3><pre><code>***\n\n---\n</code></pre><p>效果：</p>\n<hr>\n<hr>\n<h3 id=\"标记\"><a href=\"#标记\" class=\"headerlink\" title=\"标记\"></a>标记</h3><pre><code>`mark`\n</code></pre><p>效果：</p>\n<p><code>mark</code></p>\n<hr>\n<h2 id=\"附录-特殊字符\"><a href=\"#附录-特殊字符\" class=\"headerlink\" title=\"附录 特殊字符\"></a>附录 特殊字符</h2><pre><code>!     &amp;#33;\n”     &amp;#34; &amp;quot; \n#     &amp;#35; \n$     &amp;#36;\n%     &amp;#37; \n&amp;     &amp;#38; &amp;amp; \n‘     &amp;#39; \n(     &amp;#40;  \n)     &amp;#41; \n*   &amp;#42; \n+   &amp;#43;\n&lt;     &amp;#60; &amp;lt;\n=     &amp;#61; \n&gt;   &amp;#62; &amp;gt; \n?   &amp;#63;\n@   &amp;#64;\n[   &amp;#91;\n\\   &amp;#92;\n]   &amp;#93;\n{   &amp;#123;\n|   &amp;#124;\n}   &amp;#125;\n</code></pre>"},{"title":"Nginx简介及安装","date":"2018-09-08T11:32:00.000Z","_content":"\nNginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。本文主要简单介绍Nginx及linux（centos6）环境下的安装步骤。\n\n<!-- more -->\n\n# What\n\nC语言开发 轻量级 高性能 http服务器（静态资源）/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。\n\nps：官方测试nginx能够支撑5万并发连接，且CPU、内存等资源消耗非常低，运行非常稳定。\n\n# When\n\n## 反向代理\n\n反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n用途：\n可以提供从防火墙外部代理服务器到防火墙内部安全内容服务器的加密连接。\n可以允许客户机安全地连接到代理服务器，从而有利于安全地传输信息。\n\n## 负载均衡（软件）\n\n软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。\n\n当有2台或以上服务器时,根据规则随机的将请求分发到指定的服务器上处理,负载均衡配置一般都需要同时配置反向代理,通过反向代理跳转到负载均衡。 而 Nginx 目前支持自带3种负载均衡策略（RR,默认,按时间；权重；ip_hash）,还有2种常用的第三方策略。\n\n## HTTP服务器\n\nNginx 本身也是一个静态资源的服务器,当只有静态资源的时候,就可以使用 Nginx 来做服务器,同时现在也很流行动静分离。\n\n## 正向代理\n\n正向代理,意思是一个位于客户端和原始服务器(origin server)之间的服务器,为了从原始服务器取得内容,客户端向代理发送一个请求并指定目标(原始服务器),然后代理向原始服务器转交请求并将获得的内容返回给客户端。\n\nnginx的正向代理，只能代理http、tcp等，不能代理https请求。\n\n# Why\n\n1. 工作在网络的7层结构之上，可以针对http应用设置分流策略，正则规则更加强大灵活\n2. 对网络稳定性依赖小，能ping通就能进行负载功能\n3. 安装配置简单\n4. 高负载能力、高稳定、低资源消耗\n5. 可通过端口检测服务器内部故障，根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点\n6. 反向加速缓存\n7. 可作为中层反向代理使用\n8. 作为静态网页和图片服务器性能高\n9. 社区活跃，第三方模块多\n\n# Why not\n\n1. 只支持http、https、Email协议，使用范围小\n2. 不支持通过url检测后端服务器健康状态，不支持Session的直接保持（但能通过ip_hash来解决）\n\n# How\n\n## 安装\n\n### 环境准备\n\nnginx的编译需要c++，prce（重定向支持）和openssl（https支持），根据要求，本机环境情况，选择安装相应环境。\n\n\t# yum install gcc-c++\n\t# yum -y install pcre*\n\t# yum -y install openssl*\n\n### 下载并解压\n\n使用wget指令或者直接[官网](http://nginx.org/)下载。\n\n\t# cd /usr/local/\n\t# wget http://nginx.org/download/nginx-1.9.9.tar.gz\n\n解压：\n\t\n\t# tar -zxvf nginx-1.9.9.tar.gz\n\n### 编译\n\n1. 进入nginx目录\n\n\t# cd nginx-1.9.9\n\n2. 设置安装目录\n\n\t# ./configure --prefix=/usr/local/nginx\n\n3. 编译安装\n\n\t# make\n\t# make install\n\n\n### 启动nginx服务\n\n进入nginx安装目录，运行nginx。\n\t\n\t# cd /usr/local/nginx/sbin\n\t# ./nginx\n\n验证是否有nginx进程：\n\n\t# ps -ef|grep nginx\n\n### 设置开启启动\n\n1. 在/etc/init.d下创建文件nginx\n\n\t# vi /etc/init.d/nginx\n\n根据[官方脚本](http://wiki.nginx.org/RedHatNginxInitScript)修改/etc/init.d/nginx，特别注意修改以下参数：\n\n\tnginx=\"/usr/local/nginx/sbin/nginx\" \n\tNGINX_CONF_FILE=\"/usr/local/nginx/conf/nginx.conf\" \n\n2. 设置文件执行权限\n\n\t# chmod a+x /etc/init.d/nginx\n\n3. 将nginx服务加入chkconfig管理列表\n\n\t# chkconfig --add /etc/init.d/nginx\n\n4. 开机自启动\n\n\t# chkconfig nginx on\n\n### 验证安装\n\n输入IP进行访问，若有nginx的欢迎页面，则安装成功。\n\n## 常用指令\n\n\tnginx -c /usr/local/nginx/conf/nginx.conf  启动nginx\n\tnginx -s quit \t\t停止ngix\n\tnginx -s reload \t重新载入nginx(当配置信息发生修改时)\n\tnginx -s reopen \t打开日志文件\n\tnginx -v\t\t\t查看版本\n\tnginx -t\t\t\t查看nginx的配置文件的目录\n\tnginx -h  \t\t\t查看帮助信息\n\n# 安装过程问题\n\n## 问题一：zlib library：\n\t./configure: error: the HTTP gzip module requires the zlib library.\n\tYou can either disable the module by using –without-http_gzip_module\n\toption, or install the zlib library into the system, or build the zlib \n\tlibrary\n\tstatically from the source with nginx by using –with-zlib=<path> option.\n\n解决方案：\n\tyum install -y zlib-devel\t\n\n","source":"_posts/2018-09-08-Nginx_install.md","raw":"---\ntitle: Nginx简介及安装\ndate: 2018/9/8 19:32:00\ntag : \n- Synopsis\n- install\ncategories:\n- nginx\n\n---\n\nNginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。本文主要简单介绍Nginx及linux（centos6）环境下的安装步骤。\n\n<!-- more -->\n\n# What\n\nC语言开发 轻量级 高性能 http服务器（静态资源）/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。\n\nps：官方测试nginx能够支撑5万并发连接，且CPU、内存等资源消耗非常低，运行非常稳定。\n\n# When\n\n## 反向代理\n\n反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n用途：\n可以提供从防火墙外部代理服务器到防火墙内部安全内容服务器的加密连接。\n可以允许客户机安全地连接到代理服务器，从而有利于安全地传输信息。\n\n## 负载均衡（软件）\n\n软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。\n\n当有2台或以上服务器时,根据规则随机的将请求分发到指定的服务器上处理,负载均衡配置一般都需要同时配置反向代理,通过反向代理跳转到负载均衡。 而 Nginx 目前支持自带3种负载均衡策略（RR,默认,按时间；权重；ip_hash）,还有2种常用的第三方策略。\n\n## HTTP服务器\n\nNginx 本身也是一个静态资源的服务器,当只有静态资源的时候,就可以使用 Nginx 来做服务器,同时现在也很流行动静分离。\n\n## 正向代理\n\n正向代理,意思是一个位于客户端和原始服务器(origin server)之间的服务器,为了从原始服务器取得内容,客户端向代理发送一个请求并指定目标(原始服务器),然后代理向原始服务器转交请求并将获得的内容返回给客户端。\n\nnginx的正向代理，只能代理http、tcp等，不能代理https请求。\n\n# Why\n\n1. 工作在网络的7层结构之上，可以针对http应用设置分流策略，正则规则更加强大灵活\n2. 对网络稳定性依赖小，能ping通就能进行负载功能\n3. 安装配置简单\n4. 高负载能力、高稳定、低资源消耗\n5. 可通过端口检测服务器内部故障，根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点\n6. 反向加速缓存\n7. 可作为中层反向代理使用\n8. 作为静态网页和图片服务器性能高\n9. 社区活跃，第三方模块多\n\n# Why not\n\n1. 只支持http、https、Email协议，使用范围小\n2. 不支持通过url检测后端服务器健康状态，不支持Session的直接保持（但能通过ip_hash来解决）\n\n# How\n\n## 安装\n\n### 环境准备\n\nnginx的编译需要c++，prce（重定向支持）和openssl（https支持），根据要求，本机环境情况，选择安装相应环境。\n\n\t# yum install gcc-c++\n\t# yum -y install pcre*\n\t# yum -y install openssl*\n\n### 下载并解压\n\n使用wget指令或者直接[官网](http://nginx.org/)下载。\n\n\t# cd /usr/local/\n\t# wget http://nginx.org/download/nginx-1.9.9.tar.gz\n\n解压：\n\t\n\t# tar -zxvf nginx-1.9.9.tar.gz\n\n### 编译\n\n1. 进入nginx目录\n\n\t# cd nginx-1.9.9\n\n2. 设置安装目录\n\n\t# ./configure --prefix=/usr/local/nginx\n\n3. 编译安装\n\n\t# make\n\t# make install\n\n\n### 启动nginx服务\n\n进入nginx安装目录，运行nginx。\n\t\n\t# cd /usr/local/nginx/sbin\n\t# ./nginx\n\n验证是否有nginx进程：\n\n\t# ps -ef|grep nginx\n\n### 设置开启启动\n\n1. 在/etc/init.d下创建文件nginx\n\n\t# vi /etc/init.d/nginx\n\n根据[官方脚本](http://wiki.nginx.org/RedHatNginxInitScript)修改/etc/init.d/nginx，特别注意修改以下参数：\n\n\tnginx=\"/usr/local/nginx/sbin/nginx\" \n\tNGINX_CONF_FILE=\"/usr/local/nginx/conf/nginx.conf\" \n\n2. 设置文件执行权限\n\n\t# chmod a+x /etc/init.d/nginx\n\n3. 将nginx服务加入chkconfig管理列表\n\n\t# chkconfig --add /etc/init.d/nginx\n\n4. 开机自启动\n\n\t# chkconfig nginx on\n\n### 验证安装\n\n输入IP进行访问，若有nginx的欢迎页面，则安装成功。\n\n## 常用指令\n\n\tnginx -c /usr/local/nginx/conf/nginx.conf  启动nginx\n\tnginx -s quit \t\t停止ngix\n\tnginx -s reload \t重新载入nginx(当配置信息发生修改时)\n\tnginx -s reopen \t打开日志文件\n\tnginx -v\t\t\t查看版本\n\tnginx -t\t\t\t查看nginx的配置文件的目录\n\tnginx -h  \t\t\t查看帮助信息\n\n# 安装过程问题\n\n## 问题一：zlib library：\n\t./configure: error: the HTTP gzip module requires the zlib library.\n\tYou can either disable the module by using –without-http_gzip_module\n\toption, or install the zlib library into the system, or build the zlib \n\tlibrary\n\tstatically from the source with nginx by using –with-zlib=<path> option.\n\n解决方案：\n\tyum install -y zlib-devel\t\n\n","slug":"2018-09-08-Nginx_install","published":1,"updated":"2018-09-16T03:05:02.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjm4a7k3j0001dwvj5gbl1ktl","content":"<p>Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。本文主要简单介绍Nginx及linux（centos6）环境下的安装步骤。</p>\n<a id=\"more\"></a>\n<h1 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h1><p>C语言开发 轻量级 高性能 http服务器（静态资源）/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。</p>\n<p>ps：官方测试nginx能够支撑5万并发连接，且CPU、内存等资源消耗非常低，运行非常稳定。</p>\n<h1 id=\"When\"><a href=\"#When\" class=\"headerlink\" title=\"When\"></a>When</h1><h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n<p>用途：<br>可以提供从防火墙外部代理服务器到防火墙内部安全内容服务器的加密连接。<br>可以允许客户机安全地连接到代理服务器，从而有利于安全地传输信息。</p>\n<h2 id=\"负载均衡（软件）\"><a href=\"#负载均衡（软件）\" class=\"headerlink\" title=\"负载均衡（软件）\"></a>负载均衡（软件）</h2><p>软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。</p>\n<p>当有2台或以上服务器时,根据规则随机的将请求分发到指定的服务器上处理,负载均衡配置一般都需要同时配置反向代理,通过反向代理跳转到负载均衡。 而 Nginx 目前支持自带3种负载均衡策略（RR,默认,按时间；权重；ip_hash）,还有2种常用的第三方策略。</p>\n<h2 id=\"HTTP服务器\"><a href=\"#HTTP服务器\" class=\"headerlink\" title=\"HTTP服务器\"></a>HTTP服务器</h2><p>Nginx 本身也是一个静态资源的服务器,当只有静态资源的时候,就可以使用 Nginx 来做服务器,同时现在也很流行动静分离。</p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>正向代理,意思是一个位于客户端和原始服务器(origin server)之间的服务器,为了从原始服务器取得内容,客户端向代理发送一个请求并指定目标(原始服务器),然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>\n<p>nginx的正向代理，只能代理http、tcp等，不能代理https请求。</p>\n<h1 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h1><ol>\n<li>工作在网络的7层结构之上，可以针对http应用设置分流策略，正则规则更加强大灵活</li>\n<li>对网络稳定性依赖小，能ping通就能进行负载功能</li>\n<li>安装配置简单</li>\n<li>高负载能力、高稳定、低资源消耗</li>\n<li>可通过端口检测服务器内部故障，根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点</li>\n<li>反向加速缓存</li>\n<li>可作为中层反向代理使用</li>\n<li>作为静态网页和图片服务器性能高</li>\n<li>社区活跃，第三方模块多</li>\n</ol>\n<h1 id=\"Why-not\"><a href=\"#Why-not\" class=\"headerlink\" title=\"Why not\"></a>Why not</h1><ol>\n<li>只支持http、https、Email协议，使用范围小</li>\n<li>不支持通过url检测后端服务器健康状态，不支持Session的直接保持（但能通过ip_hash来解决）</li>\n</ol>\n<h1 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p>nginx的编译需要c++，prce（重定向支持）和openssl（https支持），根据要求，本机环境情况，选择安装相应环境。</p>\n<pre><code># yum install gcc-c++\n# yum -y install pcre*\n# yum -y install openssl*\n</code></pre><h3 id=\"下载并解压\"><a href=\"#下载并解压\" class=\"headerlink\" title=\"下载并解压\"></a>下载并解压</h3><p>使用wget指令或者直接<a href=\"http://nginx.org/\" target=\"_blank\" rel=\"noopener\">官网</a>下载。</p>\n<pre><code># cd /usr/local/\n# wget http://nginx.org/download/nginx-1.9.9.tar.gz\n</code></pre><p>解压：</p>\n<pre><code># tar -zxvf nginx-1.9.9.tar.gz\n</code></pre><h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><ol>\n<li><p>进入nginx目录</p>\n<h1 id=\"cd-nginx-1-9-9\"><a href=\"#cd-nginx-1-9-9\" class=\"headerlink\" title=\"cd nginx-1.9.9\"></a>cd nginx-1.9.9</h1></li>\n<li><p>设置安装目录</p>\n<h1 id=\"configure-–prefix-usr-local-nginx\"><a href=\"#configure-–prefix-usr-local-nginx\" class=\"headerlink\" title=\"./configure –prefix=/usr/local/nginx\"></a>./configure –prefix=/usr/local/nginx</h1></li>\n<li><p>编译安装</p>\n<h1 id=\"make\"><a href=\"#make\" class=\"headerlink\" title=\"make\"></a>make</h1><h1 id=\"make-install\"><a href=\"#make-install\" class=\"headerlink\" title=\"make install\"></a>make install</h1></li>\n</ol>\n<h3 id=\"启动nginx服务\"><a href=\"#启动nginx服务\" class=\"headerlink\" title=\"启动nginx服务\"></a>启动nginx服务</h3><p>进入nginx安装目录，运行nginx。</p>\n<pre><code># cd /usr/local/nginx/sbin\n# ./nginx\n</code></pre><p>验证是否有nginx进程：</p>\n<pre><code># ps -ef|grep nginx\n</code></pre><h3 id=\"设置开启启动\"><a href=\"#设置开启启动\" class=\"headerlink\" title=\"设置开启启动\"></a>设置开启启动</h3><ol>\n<li><p>在/etc/init.d下创建文件nginx</p>\n<h1 id=\"vi-etc-init-d-nginx\"><a href=\"#vi-etc-init-d-nginx\" class=\"headerlink\" title=\"vi /etc/init.d/nginx\"></a>vi /etc/init.d/nginx</h1></li>\n</ol>\n<p>根据<a href=\"http://wiki.nginx.org/RedHatNginxInitScript\" target=\"_blank\" rel=\"noopener\">官方脚本</a>修改/etc/init.d/nginx，特别注意修改以下参数：</p>\n<pre><code>nginx=&quot;/usr/local/nginx/sbin/nginx&quot; \nNGINX_CONF_FILE=&quot;/usr/local/nginx/conf/nginx.conf&quot; \n</code></pre><ol start=\"2\">\n<li><p>设置文件执行权限</p>\n<h1 id=\"chmod-a-x-etc-init-d-nginx\"><a href=\"#chmod-a-x-etc-init-d-nginx\" class=\"headerlink\" title=\"chmod a+x /etc/init.d/nginx\"></a>chmod a+x /etc/init.d/nginx</h1></li>\n<li><p>将nginx服务加入chkconfig管理列表</p>\n<h1 id=\"chkconfig-–add-etc-init-d-nginx\"><a href=\"#chkconfig-–add-etc-init-d-nginx\" class=\"headerlink\" title=\"chkconfig –add /etc/init.d/nginx\"></a>chkconfig –add /etc/init.d/nginx</h1></li>\n<li><p>开机自启动</p>\n<h1 id=\"chkconfig-nginx-on\"><a href=\"#chkconfig-nginx-on\" class=\"headerlink\" title=\"chkconfig nginx on\"></a>chkconfig nginx on</h1></li>\n</ol>\n<h3 id=\"验证安装\"><a href=\"#验证安装\" class=\"headerlink\" title=\"验证安装\"></a>验证安装</h3><p>输入IP进行访问，若有nginx的欢迎页面，则安装成功。</p>\n<h2 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><pre><code>nginx -c /usr/local/nginx/conf/nginx.conf  启动nginx\nnginx -s quit         停止ngix\nnginx -s reload     重新载入nginx(当配置信息发生修改时)\nnginx -s reopen     打开日志文件\nnginx -v            查看版本\nnginx -t            查看nginx的配置文件的目录\nnginx -h              查看帮助信息\n</code></pre><h1 id=\"安装过程问题\"><a href=\"#安装过程问题\" class=\"headerlink\" title=\"安装过程问题\"></a>安装过程问题</h1><h2 id=\"问题一：zlib-library：\"><a href=\"#问题一：zlib-library：\" class=\"headerlink\" title=\"问题一：zlib library：\"></a>问题一：zlib library：</h2><pre><code>./configure: error: the HTTP gzip module requires the zlib library.\nYou can either disable the module by using –without-http_gzip_module\noption, or install the zlib library into the system, or build the zlib \nlibrary\nstatically from the source with nginx by using –with-zlib=&lt;path&gt; option.\n</code></pre><p>解决方案：<br>    yum install -y zlib-devel    </p>\n","site":{"data":{}},"excerpt":"<p>Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。本文主要简单介绍Nginx及linux（centos6）环境下的安装步骤。</p>","more":"<h1 id=\"What\"><a href=\"#What\" class=\"headerlink\" title=\"What\"></a>What</h1><p>C语言开发 轻量级 高性能 http服务器（静态资源）/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。</p>\n<p>ps：官方测试nginx能够支撑5万并发连接，且CPU、内存等资源消耗非常低，运行非常稳定。</p>\n<h1 id=\"When\"><a href=\"#When\" class=\"headerlink\" title=\"When\"></a>When</h1><h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。</p>\n<p>用途：<br>可以提供从防火墙外部代理服务器到防火墙内部安全内容服务器的加密连接。<br>可以允许客户机安全地连接到代理服务器，从而有利于安全地传输信息。</p>\n<h2 id=\"负载均衡（软件）\"><a href=\"#负载均衡（软件）\" class=\"headerlink\" title=\"负载均衡（软件）\"></a>负载均衡（软件）</h2><p>软件负载均衡解决方案是指在一台或多台服务器相应的操作系统上安装一个或多个附加软件来实现负载均衡，它的优点是基于特定环境，配置简单，使用灵活，成本低廉，可以满足一般的负载均衡需求。</p>\n<p>当有2台或以上服务器时,根据规则随机的将请求分发到指定的服务器上处理,负载均衡配置一般都需要同时配置反向代理,通过反向代理跳转到负载均衡。 而 Nginx 目前支持自带3种负载均衡策略（RR,默认,按时间；权重；ip_hash）,还有2种常用的第三方策略。</p>\n<h2 id=\"HTTP服务器\"><a href=\"#HTTP服务器\" class=\"headerlink\" title=\"HTTP服务器\"></a>HTTP服务器</h2><p>Nginx 本身也是一个静态资源的服务器,当只有静态资源的时候,就可以使用 Nginx 来做服务器,同时现在也很流行动静分离。</p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>正向代理,意思是一个位于客户端和原始服务器(origin server)之间的服务器,为了从原始服务器取得内容,客户端向代理发送一个请求并指定目标(原始服务器),然后代理向原始服务器转交请求并将获得的内容返回给客户端。</p>\n<p>nginx的正向代理，只能代理http、tcp等，不能代理https请求。</p>\n<h1 id=\"Why\"><a href=\"#Why\" class=\"headerlink\" title=\"Why\"></a>Why</h1><ol>\n<li>工作在网络的7层结构之上，可以针对http应用设置分流策略，正则规则更加强大灵活</li>\n<li>对网络稳定性依赖小，能ping通就能进行负载功能</li>\n<li>安装配置简单</li>\n<li>高负载能力、高稳定、低资源消耗</li>\n<li>可通过端口检测服务器内部故障，根据服务器处理网页返回的状态码、超时等等，并且会把返回错误的请求重新提交到另一个节点</li>\n<li>反向加速缓存</li>\n<li>可作为中层反向代理使用</li>\n<li>作为静态网页和图片服务器性能高</li>\n<li>社区活跃，第三方模块多</li>\n</ol>\n<h1 id=\"Why-not\"><a href=\"#Why-not\" class=\"headerlink\" title=\"Why not\"></a>Why not</h1><ol>\n<li>只支持http、https、Email协议，使用范围小</li>\n<li>不支持通过url检测后端服务器健康状态，不支持Session的直接保持（但能通过ip_hash来解决）</li>\n</ol>\n<h1 id=\"How\"><a href=\"#How\" class=\"headerlink\" title=\"How\"></a>How</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><h3 id=\"环境准备\"><a href=\"#环境准备\" class=\"headerlink\" title=\"环境准备\"></a>环境准备</h3><p>nginx的编译需要c++，prce（重定向支持）和openssl（https支持），根据要求，本机环境情况，选择安装相应环境。</p>\n<pre><code># yum install gcc-c++\n# yum -y install pcre*\n# yum -y install openssl*\n</code></pre><h3 id=\"下载并解压\"><a href=\"#下载并解压\" class=\"headerlink\" title=\"下载并解压\"></a>下载并解压</h3><p>使用wget指令或者直接<a href=\"http://nginx.org/\" target=\"_blank\" rel=\"noopener\">官网</a>下载。</p>\n<pre><code># cd /usr/local/\n# wget http://nginx.org/download/nginx-1.9.9.tar.gz\n</code></pre><p>解压：</p>\n<pre><code># tar -zxvf nginx-1.9.9.tar.gz\n</code></pre><h3 id=\"编译\"><a href=\"#编译\" class=\"headerlink\" title=\"编译\"></a>编译</h3><ol>\n<li><p>进入nginx目录</p>\n<h1 id=\"cd-nginx-1-9-9\"><a href=\"#cd-nginx-1-9-9\" class=\"headerlink\" title=\"cd nginx-1.9.9\"></a>cd nginx-1.9.9</h1></li>\n<li><p>设置安装目录</p>\n<h1 id=\"configure-–prefix-usr-local-nginx\"><a href=\"#configure-–prefix-usr-local-nginx\" class=\"headerlink\" title=\"./configure –prefix=/usr/local/nginx\"></a>./configure –prefix=/usr/local/nginx</h1></li>\n<li><p>编译安装</p>\n<h1 id=\"make\"><a href=\"#make\" class=\"headerlink\" title=\"make\"></a>make</h1><h1 id=\"make-install\"><a href=\"#make-install\" class=\"headerlink\" title=\"make install\"></a>make install</h1></li>\n</ol>\n<h3 id=\"启动nginx服务\"><a href=\"#启动nginx服务\" class=\"headerlink\" title=\"启动nginx服务\"></a>启动nginx服务</h3><p>进入nginx安装目录，运行nginx。</p>\n<pre><code># cd /usr/local/nginx/sbin\n# ./nginx\n</code></pre><p>验证是否有nginx进程：</p>\n<pre><code># ps -ef|grep nginx\n</code></pre><h3 id=\"设置开启启动\"><a href=\"#设置开启启动\" class=\"headerlink\" title=\"设置开启启动\"></a>设置开启启动</h3><ol>\n<li><p>在/etc/init.d下创建文件nginx</p>\n<h1 id=\"vi-etc-init-d-nginx\"><a href=\"#vi-etc-init-d-nginx\" class=\"headerlink\" title=\"vi /etc/init.d/nginx\"></a>vi /etc/init.d/nginx</h1></li>\n</ol>\n<p>根据<a href=\"http://wiki.nginx.org/RedHatNginxInitScript\" target=\"_blank\" rel=\"noopener\">官方脚本</a>修改/etc/init.d/nginx，特别注意修改以下参数：</p>\n<pre><code>nginx=&quot;/usr/local/nginx/sbin/nginx&quot; \nNGINX_CONF_FILE=&quot;/usr/local/nginx/conf/nginx.conf&quot; \n</code></pre><ol start=\"2\">\n<li><p>设置文件执行权限</p>\n<h1 id=\"chmod-a-x-etc-init-d-nginx\"><a href=\"#chmod-a-x-etc-init-d-nginx\" class=\"headerlink\" title=\"chmod a+x /etc/init.d/nginx\"></a>chmod a+x /etc/init.d/nginx</h1></li>\n<li><p>将nginx服务加入chkconfig管理列表</p>\n<h1 id=\"chkconfig-–add-etc-init-d-nginx\"><a href=\"#chkconfig-–add-etc-init-d-nginx\" class=\"headerlink\" title=\"chkconfig –add /etc/init.d/nginx\"></a>chkconfig –add /etc/init.d/nginx</h1></li>\n<li><p>开机自启动</p>\n<h1 id=\"chkconfig-nginx-on\"><a href=\"#chkconfig-nginx-on\" class=\"headerlink\" title=\"chkconfig nginx on\"></a>chkconfig nginx on</h1></li>\n</ol>\n<h3 id=\"验证安装\"><a href=\"#验证安装\" class=\"headerlink\" title=\"验证安装\"></a>验证安装</h3><p>输入IP进行访问，若有nginx的欢迎页面，则安装成功。</p>\n<h2 id=\"常用指令\"><a href=\"#常用指令\" class=\"headerlink\" title=\"常用指令\"></a>常用指令</h2><pre><code>nginx -c /usr/local/nginx/conf/nginx.conf  启动nginx\nnginx -s quit         停止ngix\nnginx -s reload     重新载入nginx(当配置信息发生修改时)\nnginx -s reopen     打开日志文件\nnginx -v            查看版本\nnginx -t            查看nginx的配置文件的目录\nnginx -h              查看帮助信息\n</code></pre><h1 id=\"安装过程问题\"><a href=\"#安装过程问题\" class=\"headerlink\" title=\"安装过程问题\"></a>安装过程问题</h1><h2 id=\"问题一：zlib-library：\"><a href=\"#问题一：zlib-library：\" class=\"headerlink\" title=\"问题一：zlib library：\"></a>问题一：zlib library：</h2><pre><code>./configure: error: the HTTP gzip module requires the zlib library.\nYou can either disable the module by using –without-http_gzip_module\noption, or install the zlib library into the system, or build the zlib \nlibrary\nstatically from the source with nginx by using –with-zlib=&lt;path&gt; option.\n</code></pre><p>解决方案：<br>    yum install -y zlib-devel    </p>"},{"title":"深入理解JAVA虚拟机（二）  HotSpot-GC","date":"2018-09-12T11:37:00.000Z","updated":"2018-09-16T03:14:44.432Z","_content":"GC（垃圾收集；Garbage Collection）技术早于JAVA语言，随着技术的不断发展，如今内存分配与回收技术已经相当成熟。而学习JAVA的GC内容主要是为了在享受“自动化”的同时，实现对GC过程的监控和调节，分析解决内存溢出、内存泄漏等问题。\n\nps:本文主要针对HotSpot\n\n<!-- more -->\n\n# GC的原则\n\n个人总结：\n\n1. 必要性；能不进行回收就不进行回收（性能开销原因）。\n2. 专用性：只能回收内存，无法回收句柄、数据库连接等\n3. 不确定性：GC的时间时不确定的，即使主动调用GC也不能保证立马进行（安全点等因素）\n\n# GC的区域\n\nGC回收的主要区域是JAVA堆（GC最主要内存区域）、方法区（1.7及以前）或元空间（1.8）\n\n* 为何**要关注**堆及方法区的垃圾收集？堆中内存分配是动态且不可知的。\n* 为何**不关注**虚拟机栈等内存区域的垃圾收集？栈及程序计数器的内存分配随线程或方法一起创建及销毁，内存空间分配及回收是可确定的。\n\n# GC的目标\n\n## JAVA堆-对象\n\n### 判断方法\n\n根据**引用计数法**或**可达性分析法**，判断对象是否需被回收。\n\n* 引用计数法：给对象添加引用计数器，每有一个引用则加1，引用失效则减1，为0则需被回收。优点：效率高、实现简单；缺点：难以解决循环引用问题。\n* 可达性分析法：从GC-ROOT对象作为起点，向下搜索各个引用，若对象不可达（无引用链），则需被回收。  \n&nbsp;&nbsp;&nbsp;&nbsp;GC-ROOT:可作为GC-ROOT的对象包含：1、虚拟机栈中引用的对象；2、方法区中静态属性引用的对象；3、方法区中常量引用的对象；4、Native方法引用的变量。  \n&nbsp;&nbsp;&nbsp;&nbsp;引用链：从CG-ROOT出发搜索走过的路径。\n\n### 引用类型\n\n1. 强引用（Strong Reference）：不会被GC\n2. 软引用（Soft Reference）：内存快溢出时回收\n3. 弱引用（Weak Reference）：下次GC时回收\n4. 虚引用（Phantom Reference）：回收时收到系统通知\n\n### 回收过程\n\n1. 对象不可达进行时，判断是否需执行finalize方法？不需要（无或者已执行）则进入“即将回收”集合：需要（未执行）则进入F-QUEUE。\n2. F-QUEUE中的对象等待执行finalize方法（由专门的低优先级线程），虚拟机会触发该方法，但不保证方法执行完毕。\n3. GC对F-QUEUE进行标记，若已执行且无引用则进入“即将回收”集合。\n4. GC回收“即将回收”集合中的对象\n\nps：JVM只会主动触发一次对象的finalize方法（代码主动触发不计在内）\npps：不建议使用该方法\n\n关于finalize更多资料可查看[java的finalize()函数](https://www.cnblogs.com/iamzhoug37/p/4279151.html)。\n\n## 方法区-类\n\n仅当方法区中的类满足以下3个条件时，可以被回收（不一定被回收）。\n\n1. 当前类无任何实例\n2. 该类的ClassLoader对象已被回收\n3. 该类的Class对象没有被引用\n\n# GC的方法\n\n## 垃圾收集算法\n\n### 标记-清除（Mark-Sweep）\n\n* 分两阶段：标记-清除\n* 基础算法\n* 缺点：效率低，产生空间碎片\n\n### 复制（Copying）\n\n* 内存分块，其中一块使用完后，把存活对象复制到另一块，并清除当前内存块\n* 优点：无内存空间碎片\n* 缺点：内存损耗（必然有某个区域无法使用）\n\n### 标记-整理（Mark-Compact）\n\n* 标记，将存活的对象向内存的某一端移动，并清除存活对象边界外内存区域\n\n### 分代收集（Generational Collection）\n\n* 根据对象存活周期不同，将内存划分成几块，并采用相应的算法（上述算法的综合实现）\n\n## 垃圾收集器\n\n注：本部分所*并发*指其他其他用户线程可同时进行。未明确指出并发，则意味其他用户线程必须等待GC线程执行完毕。\n\n### Serial\n\n* 算法：复制算法（新生代） 标记-整理（老年代）\n* 类型：单线程\n* 特点：简单高效\n* 缺点：STW时间长\n* 应用场景：单核处理器、桌面应用\n\n### ParNew\n\n* 算法：复制算法（新生代） 标记-整理（老年代）\n* 类型：多线程（新生代） 单线程（老年代）\n* 特点：Serial升级版，可与CMS配合使用\n* 缺点：存在线程交互的开销\n* 应用场景：默认新生代收集器\n\n### Parallel Scavenge\n\n* 算法：复制算法\n* 类型：多线程\n* 特点：吞吐量（STW占用执行时间比例）可控、参数自适应\n* 缺点：没有好的可配合使用的老年代收集器\n\n### Serial Old\n\n* Serial的老年代收集器\n* 作为CMS的备选及以前与Parallel配合使用\n\n### Parallel Old\n\n* 区域：老年代\n* 算法：标记-整理算法\n* 类型：多线程\n* 特点：吞吐量优先\n* 应用场景：注重吞吐量及CPU敏感的场合\n\n### CMS\n\n* 区域：老年代\n* 算法：标记-清除算法\n* 特点：注重低回收停顿时间\n* 应用场景：默认\n* 过程：  \n&nbsp;&nbsp;&nbsp;&nbsp;初始标记（单线程），可达标记\n&nbsp;&nbsp;&nbsp;&nbsp;并发标记（单线程，并发），执行GC-ROOT Tracing\n&nbsp;&nbsp;&nbsp;&nbsp;重新标记（多线程），修正因程序执行变动的对象\n&nbsp;&nbsp;&nbsp;&nbsp;并发清除（单线程，并发）清除\n* 缺点：1、CPU占用率高；2、无法清除浮动垃圾；3、产生空间碎片（碎片过多无法存放对向时，会提前触发FULL GC）\n\n### G1\n\n* 区域：堆划分的多个独立区域（Region）（新生代及老年代为Region的集合）\n* 算法：标记-整理算法（整体而言） 复制算法（两个Region之间）\n* 思想：化整数为零\n* 特点：并发与并行、分代收集、空间整合、可预测的停顿\n* 过程：  \n&nbsp;&nbsp;&nbsp;&nbsp;初始标记（单线程）\n&nbsp;&nbsp;&nbsp;&nbsp;并发标记（单线程，并发）\n&nbsp;&nbsp;&nbsp;&nbsp;最终标记（多线程）\n&nbsp;&nbsp;&nbsp;&nbsp;筛选回收（多线程）\n（将耗时最长的并发标记与用户线程并发执行）\n\n{% asset_img GCCLass.jpg 各GC收集器的类型及配合使用情况 %}\n\nPS：针对G1的Region之间及其他垃圾回收器新生代和老年代之间对象的引用，为避免全堆扫描，会维护一个Remembered Set（G1中每个Refion都由各自的Set），在对引用类型数据进行操作时，判断对象是否在不同的区域中，若是，则通过CardTable把相关引用信息记录到Remembered Set中，并在GC时，把Remembered Set加入GC-Root即可。\n\n---\n\n# 对象内存分配策略\n\n对象分配策略并非固定，与所用的垃圾收集器及虚拟机参数有关，一般而言，按照以下原则分配\n\n## 优先分配Eden区\n\n对象分配时，将优先分配到Eden区，若Eden区空间不足，会先发起一次Minor GC\n\n## 大对象直接进入老年代\n\n根据虚拟机参数，若对象为大对象，则直接进入老年代\n\n## 长期存活对象进入老年代\n\n默认年龄为15的对象（经过15次Minor GC）的对象将进入老年代\n\n## 动态年龄判断\n\nSurvivor空间中相同年龄的对象所占空间总和大于Survivor的一半，则直接进入老年代。\n\n## 空间分配担保\n\n若开启空间分配担保，在Minor GC时，若servivor无法存放存活对象，则淬火对象直接进入老年代。若担保失败，会触发Full GC。\n\n## Minor GC or Full GC\n\n### Minor GC\n1. 当Eden区满时，触发Minor GC。\n\n### Full GC\n\n1. 调用System.gc时，系统建议执行Full GC，但是不必然执行\n2. 老年代空间不足\n3. 方法区空间不足\n4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存\n5. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小\n\n# HotSpot GC算法实现\n\n## 枚举根节点（可达性分析实现）\n\n问题：如何定位对象的哪些位置是引用？  \n\n* 解决：使用一组OppMap的数据结构来获取对象引用的位置。  \n* 原理：在类加载过程中，直接计算出大对象内什么偏移量上时什么数据类型；在JIT编译过程中，在特定位置记录栈和寄存器中哪些位置是引用。GC时即可得知对象引用信息\n\n## 安全点（解决如何进入GC问题）\n\n问题1：为每条指令创建OopMap，需要大量额外空间\n\n* 解决：设置安全点（Safepoint），在特定位置才记录OopMap信息。\n* 设置标准：是否具有让长时间执行的特征（即方法调用、循环跳转、异常跳转等）\n\n问题2：多线程时如何让所以线程都到安全点\n\n* 解决：\n&nbsp;&nbsp;&nbsp;&nbsp;抢先式中断：先中断所有线程，若由线程不在安全点，则恢复该线程，并让其执行到安全点上。\n&nbsp;&nbsp;&nbsp;&nbsp;主动式中断：设置一个标志，各个线程轮询，若需中断，则线程自己中断\n\n## 安全区域（解决线程挂起等待行时无法到达安全点问题）\n\n安全区域（Safe Region）指在一段代码片段中，引用关系不再发生变化。线程执行到安全区域时标识自己已经进入安全区域，在发起GC时，即可忽略进入安全区域的线程。\n\n\n\n***\n\n<small>2018-09-12 23:09    Cyalud    Xiamen</small>","source":"_posts/2018-09-12-JVM_BASIC_GC.md","raw":"---\ntitle: 深入理解JAVA虚拟机（二）  HotSpot-GC\ndate: 2018/9/12 19:37:00\nupdated: \ntag: \n- JVM\n- GC\ncategories:\n- Java\n\n\n---\nGC（垃圾收集；Garbage Collection）技术早于JAVA语言，随着技术的不断发展，如今内存分配与回收技术已经相当成熟。而学习JAVA的GC内容主要是为了在享受“自动化”的同时，实现对GC过程的监控和调节，分析解决内存溢出、内存泄漏等问题。\n\nps:本文主要针对HotSpot\n\n<!-- more -->\n\n# GC的原则\n\n个人总结：\n\n1. 必要性；能不进行回收就不进行回收（性能开销原因）。\n2. 专用性：只能回收内存，无法回收句柄、数据库连接等\n3. 不确定性：GC的时间时不确定的，即使主动调用GC也不能保证立马进行（安全点等因素）\n\n# GC的区域\n\nGC回收的主要区域是JAVA堆（GC最主要内存区域）、方法区（1.7及以前）或元空间（1.8）\n\n* 为何**要关注**堆及方法区的垃圾收集？堆中内存分配是动态且不可知的。\n* 为何**不关注**虚拟机栈等内存区域的垃圾收集？栈及程序计数器的内存分配随线程或方法一起创建及销毁，内存空间分配及回收是可确定的。\n\n# GC的目标\n\n## JAVA堆-对象\n\n### 判断方法\n\n根据**引用计数法**或**可达性分析法**，判断对象是否需被回收。\n\n* 引用计数法：给对象添加引用计数器，每有一个引用则加1，引用失效则减1，为0则需被回收。优点：效率高、实现简单；缺点：难以解决循环引用问题。\n* 可达性分析法：从GC-ROOT对象作为起点，向下搜索各个引用，若对象不可达（无引用链），则需被回收。  \n&nbsp;&nbsp;&nbsp;&nbsp;GC-ROOT:可作为GC-ROOT的对象包含：1、虚拟机栈中引用的对象；2、方法区中静态属性引用的对象；3、方法区中常量引用的对象；4、Native方法引用的变量。  \n&nbsp;&nbsp;&nbsp;&nbsp;引用链：从CG-ROOT出发搜索走过的路径。\n\n### 引用类型\n\n1. 强引用（Strong Reference）：不会被GC\n2. 软引用（Soft Reference）：内存快溢出时回收\n3. 弱引用（Weak Reference）：下次GC时回收\n4. 虚引用（Phantom Reference）：回收时收到系统通知\n\n### 回收过程\n\n1. 对象不可达进行时，判断是否需执行finalize方法？不需要（无或者已执行）则进入“即将回收”集合：需要（未执行）则进入F-QUEUE。\n2. F-QUEUE中的对象等待执行finalize方法（由专门的低优先级线程），虚拟机会触发该方法，但不保证方法执行完毕。\n3. GC对F-QUEUE进行标记，若已执行且无引用则进入“即将回收”集合。\n4. GC回收“即将回收”集合中的对象\n\nps：JVM只会主动触发一次对象的finalize方法（代码主动触发不计在内）\npps：不建议使用该方法\n\n关于finalize更多资料可查看[java的finalize()函数](https://www.cnblogs.com/iamzhoug37/p/4279151.html)。\n\n## 方法区-类\n\n仅当方法区中的类满足以下3个条件时，可以被回收（不一定被回收）。\n\n1. 当前类无任何实例\n2. 该类的ClassLoader对象已被回收\n3. 该类的Class对象没有被引用\n\n# GC的方法\n\n## 垃圾收集算法\n\n### 标记-清除（Mark-Sweep）\n\n* 分两阶段：标记-清除\n* 基础算法\n* 缺点：效率低，产生空间碎片\n\n### 复制（Copying）\n\n* 内存分块，其中一块使用完后，把存活对象复制到另一块，并清除当前内存块\n* 优点：无内存空间碎片\n* 缺点：内存损耗（必然有某个区域无法使用）\n\n### 标记-整理（Mark-Compact）\n\n* 标记，将存活的对象向内存的某一端移动，并清除存活对象边界外内存区域\n\n### 分代收集（Generational Collection）\n\n* 根据对象存活周期不同，将内存划分成几块，并采用相应的算法（上述算法的综合实现）\n\n## 垃圾收集器\n\n注：本部分所*并发*指其他其他用户线程可同时进行。未明确指出并发，则意味其他用户线程必须等待GC线程执行完毕。\n\n### Serial\n\n* 算法：复制算法（新生代） 标记-整理（老年代）\n* 类型：单线程\n* 特点：简单高效\n* 缺点：STW时间长\n* 应用场景：单核处理器、桌面应用\n\n### ParNew\n\n* 算法：复制算法（新生代） 标记-整理（老年代）\n* 类型：多线程（新生代） 单线程（老年代）\n* 特点：Serial升级版，可与CMS配合使用\n* 缺点：存在线程交互的开销\n* 应用场景：默认新生代收集器\n\n### Parallel Scavenge\n\n* 算法：复制算法\n* 类型：多线程\n* 特点：吞吐量（STW占用执行时间比例）可控、参数自适应\n* 缺点：没有好的可配合使用的老年代收集器\n\n### Serial Old\n\n* Serial的老年代收集器\n* 作为CMS的备选及以前与Parallel配合使用\n\n### Parallel Old\n\n* 区域：老年代\n* 算法：标记-整理算法\n* 类型：多线程\n* 特点：吞吐量优先\n* 应用场景：注重吞吐量及CPU敏感的场合\n\n### CMS\n\n* 区域：老年代\n* 算法：标记-清除算法\n* 特点：注重低回收停顿时间\n* 应用场景：默认\n* 过程：  \n&nbsp;&nbsp;&nbsp;&nbsp;初始标记（单线程），可达标记\n&nbsp;&nbsp;&nbsp;&nbsp;并发标记（单线程，并发），执行GC-ROOT Tracing\n&nbsp;&nbsp;&nbsp;&nbsp;重新标记（多线程），修正因程序执行变动的对象\n&nbsp;&nbsp;&nbsp;&nbsp;并发清除（单线程，并发）清除\n* 缺点：1、CPU占用率高；2、无法清除浮动垃圾；3、产生空间碎片（碎片过多无法存放对向时，会提前触发FULL GC）\n\n### G1\n\n* 区域：堆划分的多个独立区域（Region）（新生代及老年代为Region的集合）\n* 算法：标记-整理算法（整体而言） 复制算法（两个Region之间）\n* 思想：化整数为零\n* 特点：并发与并行、分代收集、空间整合、可预测的停顿\n* 过程：  \n&nbsp;&nbsp;&nbsp;&nbsp;初始标记（单线程）\n&nbsp;&nbsp;&nbsp;&nbsp;并发标记（单线程，并发）\n&nbsp;&nbsp;&nbsp;&nbsp;最终标记（多线程）\n&nbsp;&nbsp;&nbsp;&nbsp;筛选回收（多线程）\n（将耗时最长的并发标记与用户线程并发执行）\n\n{% asset_img GCCLass.jpg 各GC收集器的类型及配合使用情况 %}\n\nPS：针对G1的Region之间及其他垃圾回收器新生代和老年代之间对象的引用，为避免全堆扫描，会维护一个Remembered Set（G1中每个Refion都由各自的Set），在对引用类型数据进行操作时，判断对象是否在不同的区域中，若是，则通过CardTable把相关引用信息记录到Remembered Set中，并在GC时，把Remembered Set加入GC-Root即可。\n\n---\n\n# 对象内存分配策略\n\n对象分配策略并非固定，与所用的垃圾收集器及虚拟机参数有关，一般而言，按照以下原则分配\n\n## 优先分配Eden区\n\n对象分配时，将优先分配到Eden区，若Eden区空间不足，会先发起一次Minor GC\n\n## 大对象直接进入老年代\n\n根据虚拟机参数，若对象为大对象，则直接进入老年代\n\n## 长期存活对象进入老年代\n\n默认年龄为15的对象（经过15次Minor GC）的对象将进入老年代\n\n## 动态年龄判断\n\nSurvivor空间中相同年龄的对象所占空间总和大于Survivor的一半，则直接进入老年代。\n\n## 空间分配担保\n\n若开启空间分配担保，在Minor GC时，若servivor无法存放存活对象，则淬火对象直接进入老年代。若担保失败，会触发Full GC。\n\n## Minor GC or Full GC\n\n### Minor GC\n1. 当Eden区满时，触发Minor GC。\n\n### Full GC\n\n1. 调用System.gc时，系统建议执行Full GC，但是不必然执行\n2. 老年代空间不足\n3. 方法区空间不足\n4. 通过Minor GC后进入老年代的平均大小大于老年代的可用内存\n5. 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小\n\n# HotSpot GC算法实现\n\n## 枚举根节点（可达性分析实现）\n\n问题：如何定位对象的哪些位置是引用？  \n\n* 解决：使用一组OppMap的数据结构来获取对象引用的位置。  \n* 原理：在类加载过程中，直接计算出大对象内什么偏移量上时什么数据类型；在JIT编译过程中，在特定位置记录栈和寄存器中哪些位置是引用。GC时即可得知对象引用信息\n\n## 安全点（解决如何进入GC问题）\n\n问题1：为每条指令创建OopMap，需要大量额外空间\n\n* 解决：设置安全点（Safepoint），在特定位置才记录OopMap信息。\n* 设置标准：是否具有让长时间执行的特征（即方法调用、循环跳转、异常跳转等）\n\n问题2：多线程时如何让所以线程都到安全点\n\n* 解决：\n&nbsp;&nbsp;&nbsp;&nbsp;抢先式中断：先中断所有线程，若由线程不在安全点，则恢复该线程，并让其执行到安全点上。\n&nbsp;&nbsp;&nbsp;&nbsp;主动式中断：设置一个标志，各个线程轮询，若需中断，则线程自己中断\n\n## 安全区域（解决线程挂起等待行时无法到达安全点问题）\n\n安全区域（Safe Region）指在一段代码片段中，引用关系不再发生变化。线程执行到安全区域时标识自己已经进入安全区域，在发起GC时，即可忽略进入安全区域的线程。\n\n\n\n***\n\n<small>2018-09-12 23:09    Cyalud    Xiamen</small>","slug":"2018-09-12-JVM_BASIC_GC","published":1,"_id":"cjm4a7k3n0004dwvjuthywlk8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>GC（垃圾收集；Garbage Collection）技术早于JAVA语言，随着技术的不断发展，如今内存分配与回收技术已经相当成熟。而学习JAVA的GC内容主要是为了在享受“自动化”的同时，实现对GC过程的监控和调节，分析解决内存溢出、内存泄漏等问题。</p>\n<p>ps:本文主要针对HotSpot</p>\n<a id=\"more\"></a>\n<h1 id=\"GC的原则\"><a href=\"#GC的原则\" class=\"headerlink\" title=\"GC的原则\"></a>GC的原则</h1><p>个人总结：</p>\n<ol>\n<li>必要性；能不进行回收就不进行回收（性能开销原因）。</li>\n<li>专用性：只能回收内存，无法回收句柄、数据库连接等</li>\n<li>不确定性：GC的时间时不确定的，即使主动调用GC也不能保证立马进行（安全点等因素）</li>\n</ol>\n<h1 id=\"GC的区域\"><a href=\"#GC的区域\" class=\"headerlink\" title=\"GC的区域\"></a>GC的区域</h1><p>GC回收的主要区域是JAVA堆（GC最主要内存区域）、方法区（1.7及以前）或元空间（1.8）</p>\n<ul>\n<li>为何<strong>要关注</strong>堆及方法区的垃圾收集？堆中内存分配是动态且不可知的。</li>\n<li>为何<strong>不关注</strong>虚拟机栈等内存区域的垃圾收集？栈及程序计数器的内存分配随线程或方法一起创建及销毁，内存空间分配及回收是可确定的。</li>\n</ul>\n<h1 id=\"GC的目标\"><a href=\"#GC的目标\" class=\"headerlink\" title=\"GC的目标\"></a>GC的目标</h1><h2 id=\"JAVA堆-对象\"><a href=\"#JAVA堆-对象\" class=\"headerlink\" title=\"JAVA堆-对象\"></a>JAVA堆-对象</h2><h3 id=\"判断方法\"><a href=\"#判断方法\" class=\"headerlink\" title=\"判断方法\"></a>判断方法</h3><p>根据<strong>引用计数法</strong>或<strong>可达性分析法</strong>，判断对象是否需被回收。</p>\n<ul>\n<li>引用计数法：给对象添加引用计数器，每有一个引用则加1，引用失效则减1，为0则需被回收。优点：效率高、实现简单；缺点：难以解决循环引用问题。</li>\n<li>可达性分析法：从GC-ROOT对象作为起点，向下搜索各个引用，若对象不可达（无引用链），则需被回收。<br>&nbsp;&nbsp;&nbsp;&nbsp;GC-ROOT:可作为GC-ROOT的对象包含：1、虚拟机栈中引用的对象；2、方法区中静态属性引用的对象；3、方法区中常量引用的对象；4、Native方法引用的变量。<br>&nbsp;&nbsp;&nbsp;&nbsp;引用链：从CG-ROOT出发搜索走过的路径。</li>\n</ul>\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><ol>\n<li>强引用（Strong Reference）：不会被GC</li>\n<li>软引用（Soft Reference）：内存快溢出时回收</li>\n<li>弱引用（Weak Reference）：下次GC时回收</li>\n<li>虚引用（Phantom Reference）：回收时收到系统通知</li>\n</ol>\n<h3 id=\"回收过程\"><a href=\"#回收过程\" class=\"headerlink\" title=\"回收过程\"></a>回收过程</h3><ol>\n<li>对象不可达进行时，判断是否需执行finalize方法？不需要（无或者已执行）则进入“即将回收”集合：需要（未执行）则进入F-QUEUE。</li>\n<li>F-QUEUE中的对象等待执行finalize方法（由专门的低优先级线程），虚拟机会触发该方法，但不保证方法执行完毕。</li>\n<li>GC对F-QUEUE进行标记，若已执行且无引用则进入“即将回收”集合。</li>\n<li>GC回收“即将回收”集合中的对象</li>\n</ol>\n<p>ps：JVM只会主动触发一次对象的finalize方法（代码主动触发不计在内）<br>pps：不建议使用该方法</p>\n<p>关于finalize更多资料可查看<a href=\"https://www.cnblogs.com/iamzhoug37/p/4279151.html\" target=\"_blank\" rel=\"noopener\">java的finalize()函数</a>。</p>\n<h2 id=\"方法区-类\"><a href=\"#方法区-类\" class=\"headerlink\" title=\"方法区-类\"></a>方法区-类</h2><p>仅当方法区中的类满足以下3个条件时，可以被回收（不一定被回收）。</p>\n<ol>\n<li>当前类无任何实例</li>\n<li>该类的ClassLoader对象已被回收</li>\n<li>该类的Class对象没有被引用</li>\n</ol>\n<h1 id=\"GC的方法\"><a href=\"#GC的方法\" class=\"headerlink\" title=\"GC的方法\"></a>GC的方法</h1><h2 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h2><h3 id=\"标记-清除（Mark-Sweep）\"><a href=\"#标记-清除（Mark-Sweep）\" class=\"headerlink\" title=\"标记-清除（Mark-Sweep）\"></a>标记-清除（Mark-Sweep）</h3><ul>\n<li>分两阶段：标记-清除</li>\n<li>基础算法</li>\n<li>缺点：效率低，产生空间碎片</li>\n</ul>\n<h3 id=\"复制（Copying）\"><a href=\"#复制（Copying）\" class=\"headerlink\" title=\"复制（Copying）\"></a>复制（Copying）</h3><ul>\n<li>内存分块，其中一块使用完后，把存活对象复制到另一块，并清除当前内存块</li>\n<li>优点：无内存空间碎片</li>\n<li>缺点：内存损耗（必然有某个区域无法使用）</li>\n</ul>\n<h3 id=\"标记-整理（Mark-Compact）\"><a href=\"#标记-整理（Mark-Compact）\" class=\"headerlink\" title=\"标记-整理（Mark-Compact）\"></a>标记-整理（Mark-Compact）</h3><ul>\n<li>标记，将存活的对象向内存的某一端移动，并清除存活对象边界外内存区域</li>\n</ul>\n<h3 id=\"分代收集（Generational-Collection）\"><a href=\"#分代收集（Generational-Collection）\" class=\"headerlink\" title=\"分代收集（Generational Collection）\"></a>分代收集（Generational Collection）</h3><ul>\n<li>根据对象存活周期不同，将内存划分成几块，并采用相应的算法（上述算法的综合实现）</li>\n</ul>\n<h2 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h2><p>注：本部分所<em>并发</em>指其他其他用户线程可同时进行。未明确指出并发，则意味其他用户线程必须等待GC线程执行完毕。</p>\n<h3 id=\"Serial\"><a href=\"#Serial\" class=\"headerlink\" title=\"Serial\"></a>Serial</h3><ul>\n<li>算法：复制算法（新生代） 标记-整理（老年代）</li>\n<li>类型：单线程</li>\n<li>特点：简单高效</li>\n<li>缺点：STW时间长</li>\n<li>应用场景：单核处理器、桌面应用</li>\n</ul>\n<h3 id=\"ParNew\"><a href=\"#ParNew\" class=\"headerlink\" title=\"ParNew\"></a>ParNew</h3><ul>\n<li>算法：复制算法（新生代） 标记-整理（老年代）</li>\n<li>类型：多线程（新生代） 单线程（老年代）</li>\n<li>特点：Serial升级版，可与CMS配合使用</li>\n<li>缺点：存在线程交互的开销</li>\n<li>应用场景：默认新生代收集器</li>\n</ul>\n<h3 id=\"Parallel-Scavenge\"><a href=\"#Parallel-Scavenge\" class=\"headerlink\" title=\"Parallel Scavenge\"></a>Parallel Scavenge</h3><ul>\n<li>算法：复制算法</li>\n<li>类型：多线程</li>\n<li>特点：吞吐量（STW占用执行时间比例）可控、参数自适应</li>\n<li>缺点：没有好的可配合使用的老年代收集器</li>\n</ul>\n<h3 id=\"Serial-Old\"><a href=\"#Serial-Old\" class=\"headerlink\" title=\"Serial Old\"></a>Serial Old</h3><ul>\n<li>Serial的老年代收集器</li>\n<li>作为CMS的备选及以前与Parallel配合使用</li>\n</ul>\n<h3 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h3><ul>\n<li>区域：老年代</li>\n<li>算法：标记-整理算法</li>\n<li>类型：多线程</li>\n<li>特点：吞吐量优先</li>\n<li>应用场景：注重吞吐量及CPU敏感的场合</li>\n</ul>\n<h3 id=\"CMS\"><a href=\"#CMS\" class=\"headerlink\" title=\"CMS\"></a>CMS</h3><ul>\n<li>区域：老年代</li>\n<li>算法：标记-清除算法</li>\n<li>特点：注重低回收停顿时间</li>\n<li>应用场景：默认</li>\n<li>过程：<br>&nbsp;&nbsp;&nbsp;&nbsp;初始标记（单线程），可达标记<br>&nbsp;&nbsp;&nbsp;&nbsp;并发标记（单线程，并发），执行GC-ROOT Tracing<br>&nbsp;&nbsp;&nbsp;&nbsp;重新标记（多线程），修正因程序执行变动的对象<br>&nbsp;&nbsp;&nbsp;&nbsp;并发清除（单线程，并发）清除</li>\n<li>缺点：1、CPU占用率高；2、无法清除浮动垃圾；3、产生空间碎片（碎片过多无法存放对向时，会提前触发FULL GC）</li>\n</ul>\n<h3 id=\"G1\"><a href=\"#G1\" class=\"headerlink\" title=\"G1\"></a>G1</h3><ul>\n<li>区域：堆划分的多个独立区域（Region）（新生代及老年代为Region的集合）</li>\n<li>算法：标记-整理算法（整体而言） 复制算法（两个Region之间）</li>\n<li>思想：化整数为零</li>\n<li>特点：并发与并行、分代收集、空间整合、可预测的停顿</li>\n<li>过程：<br>&nbsp;&nbsp;&nbsp;&nbsp;初始标记（单线程）<br>&nbsp;&nbsp;&nbsp;&nbsp;并发标记（单线程，并发）<br>&nbsp;&nbsp;&nbsp;&nbsp;最终标记（多线程）<br>&nbsp;&nbsp;&nbsp;&nbsp;筛选回收（多线程）<br>（将耗时最长的并发标记与用户线程并发执行）</li>\n</ul>\n\n<p>PS：针对G1的Region之间及其他垃圾回收器新生代和老年代之间对象的引用，为避免全堆扫描，会维护一个Remembered Set（G1中每个Refion都由各自的Set），在对引用类型数据进行操作时，判断对象是否在不同的区域中，若是，则通过CardTable把相关引用信息记录到Remembered Set中，并在GC时，把Remembered Set加入GC-Root即可。</p>\n<hr>\n<h1 id=\"对象内存分配策略\"><a href=\"#对象内存分配策略\" class=\"headerlink\" title=\"对象内存分配策略\"></a>对象内存分配策略</h1><p>对象分配策略并非固定，与所用的垃圾收集器及虚拟机参数有关，一般而言，按照以下原则分配</p>\n<h2 id=\"优先分配Eden区\"><a href=\"#优先分配Eden区\" class=\"headerlink\" title=\"优先分配Eden区\"></a>优先分配Eden区</h2><p>对象分配时，将优先分配到Eden区，若Eden区空间不足，会先发起一次Minor GC</p>\n<h2 id=\"大对象直接进入老年代\"><a href=\"#大对象直接进入老年代\" class=\"headerlink\" title=\"大对象直接进入老年代\"></a>大对象直接进入老年代</h2><p>根据虚拟机参数，若对象为大对象，则直接进入老年代</p>\n<h2 id=\"长期存活对象进入老年代\"><a href=\"#长期存活对象进入老年代\" class=\"headerlink\" title=\"长期存活对象进入老年代\"></a>长期存活对象进入老年代</h2><p>默认年龄为15的对象（经过15次Minor GC）的对象将进入老年代</p>\n<h2 id=\"动态年龄判断\"><a href=\"#动态年龄判断\" class=\"headerlink\" title=\"动态年龄判断\"></a>动态年龄判断</h2><p>Survivor空间中相同年龄的对象所占空间总和大于Survivor的一半，则直接进入老年代。</p>\n<h2 id=\"空间分配担保\"><a href=\"#空间分配担保\" class=\"headerlink\" title=\"空间分配担保\"></a>空间分配担保</h2><p>若开启空间分配担保，在Minor GC时，若servivor无法存放存活对象，则淬火对象直接进入老年代。若担保失败，会触发Full GC。</p>\n<h2 id=\"Minor-GC-or-Full-GC\"><a href=\"#Minor-GC-or-Full-GC\" class=\"headerlink\" title=\"Minor GC or Full GC\"></a>Minor GC or Full GC</h2><h3 id=\"Minor-GC\"><a href=\"#Minor-GC\" class=\"headerlink\" title=\"Minor GC\"></a>Minor GC</h3><ol>\n<li>当Eden区满时，触发Minor GC。</li>\n</ol>\n<h3 id=\"Full-GC\"><a href=\"#Full-GC\" class=\"headerlink\" title=\"Full GC\"></a>Full GC</h3><ol>\n<li>调用System.gc时，系统建议执行Full GC，但是不必然执行</li>\n<li>老年代空间不足</li>\n<li>方法区空间不足</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>\n<li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>\n</ol>\n<h1 id=\"HotSpot-GC算法实现\"><a href=\"#HotSpot-GC算法实现\" class=\"headerlink\" title=\"HotSpot GC算法实现\"></a>HotSpot GC算法实现</h1><h2 id=\"枚举根节点（可达性分析实现）\"><a href=\"#枚举根节点（可达性分析实现）\" class=\"headerlink\" title=\"枚举根节点（可达性分析实现）\"></a>枚举根节点（可达性分析实现）</h2><p>问题：如何定位对象的哪些位置是引用？  </p>\n<ul>\n<li>解决：使用一组OppMap的数据结构来获取对象引用的位置。  </li>\n<li>原理：在类加载过程中，直接计算出大对象内什么偏移量上时什么数据类型；在JIT编译过程中，在特定位置记录栈和寄存器中哪些位置是引用。GC时即可得知对象引用信息</li>\n</ul>\n<h2 id=\"安全点（解决如何进入GC问题）\"><a href=\"#安全点（解决如何进入GC问题）\" class=\"headerlink\" title=\"安全点（解决如何进入GC问题）\"></a>安全点（解决如何进入GC问题）</h2><p>问题1：为每条指令创建OopMap，需要大量额外空间</p>\n<ul>\n<li>解决：设置安全点（Safepoint），在特定位置才记录OopMap信息。</li>\n<li>设置标准：是否具有让长时间执行的特征（即方法调用、循环跳转、异常跳转等）</li>\n</ul>\n<p>问题2：多线程时如何让所以线程都到安全点</p>\n<ul>\n<li>解决：<br>&nbsp;&nbsp;&nbsp;&nbsp;抢先式中断：先中断所有线程，若由线程不在安全点，则恢复该线程，并让其执行到安全点上。<br>&nbsp;&nbsp;&nbsp;&nbsp;主动式中断：设置一个标志，各个线程轮询，若需中断，则线程自己中断</li>\n</ul>\n<h2 id=\"安全区域（解决线程挂起等待行时无法到达安全点问题）\"><a href=\"#安全区域（解决线程挂起等待行时无法到达安全点问题）\" class=\"headerlink\" title=\"安全区域（解决线程挂起等待行时无法到达安全点问题）\"></a>安全区域（解决线程挂起等待行时无法到达安全点问题）</h2><p>安全区域（Safe Region）指在一段代码片段中，引用关系不再发生变化。线程执行到安全区域时标识自己已经进入安全区域，在发起GC时，即可忽略进入安全区域的线程。</p>\n<hr>\n<p><small>2018-09-12 23:09    Cyalud    Xiamen</small></p>\n","site":{"data":{}},"excerpt":"<p>GC（垃圾收集；Garbage Collection）技术早于JAVA语言，随着技术的不断发展，如今内存分配与回收技术已经相当成熟。而学习JAVA的GC内容主要是为了在享受“自动化”的同时，实现对GC过程的监控和调节，分析解决内存溢出、内存泄漏等问题。</p>\n<p>ps:本文主要针对HotSpot</p>","more":"<h1 id=\"GC的原则\"><a href=\"#GC的原则\" class=\"headerlink\" title=\"GC的原则\"></a>GC的原则</h1><p>个人总结：</p>\n<ol>\n<li>必要性；能不进行回收就不进行回收（性能开销原因）。</li>\n<li>专用性：只能回收内存，无法回收句柄、数据库连接等</li>\n<li>不确定性：GC的时间时不确定的，即使主动调用GC也不能保证立马进行（安全点等因素）</li>\n</ol>\n<h1 id=\"GC的区域\"><a href=\"#GC的区域\" class=\"headerlink\" title=\"GC的区域\"></a>GC的区域</h1><p>GC回收的主要区域是JAVA堆（GC最主要内存区域）、方法区（1.7及以前）或元空间（1.8）</p>\n<ul>\n<li>为何<strong>要关注</strong>堆及方法区的垃圾收集？堆中内存分配是动态且不可知的。</li>\n<li>为何<strong>不关注</strong>虚拟机栈等内存区域的垃圾收集？栈及程序计数器的内存分配随线程或方法一起创建及销毁，内存空间分配及回收是可确定的。</li>\n</ul>\n<h1 id=\"GC的目标\"><a href=\"#GC的目标\" class=\"headerlink\" title=\"GC的目标\"></a>GC的目标</h1><h2 id=\"JAVA堆-对象\"><a href=\"#JAVA堆-对象\" class=\"headerlink\" title=\"JAVA堆-对象\"></a>JAVA堆-对象</h2><h3 id=\"判断方法\"><a href=\"#判断方法\" class=\"headerlink\" title=\"判断方法\"></a>判断方法</h3><p>根据<strong>引用计数法</strong>或<strong>可达性分析法</strong>，判断对象是否需被回收。</p>\n<ul>\n<li>引用计数法：给对象添加引用计数器，每有一个引用则加1，引用失效则减1，为0则需被回收。优点：效率高、实现简单；缺点：难以解决循环引用问题。</li>\n<li>可达性分析法：从GC-ROOT对象作为起点，向下搜索各个引用，若对象不可达（无引用链），则需被回收。<br>&nbsp;&nbsp;&nbsp;&nbsp;GC-ROOT:可作为GC-ROOT的对象包含：1、虚拟机栈中引用的对象；2、方法区中静态属性引用的对象；3、方法区中常量引用的对象；4、Native方法引用的变量。<br>&nbsp;&nbsp;&nbsp;&nbsp;引用链：从CG-ROOT出发搜索走过的路径。</li>\n</ul>\n<h3 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h3><ol>\n<li>强引用（Strong Reference）：不会被GC</li>\n<li>软引用（Soft Reference）：内存快溢出时回收</li>\n<li>弱引用（Weak Reference）：下次GC时回收</li>\n<li>虚引用（Phantom Reference）：回收时收到系统通知</li>\n</ol>\n<h3 id=\"回收过程\"><a href=\"#回收过程\" class=\"headerlink\" title=\"回收过程\"></a>回收过程</h3><ol>\n<li>对象不可达进行时，判断是否需执行finalize方法？不需要（无或者已执行）则进入“即将回收”集合：需要（未执行）则进入F-QUEUE。</li>\n<li>F-QUEUE中的对象等待执行finalize方法（由专门的低优先级线程），虚拟机会触发该方法，但不保证方法执行完毕。</li>\n<li>GC对F-QUEUE进行标记，若已执行且无引用则进入“即将回收”集合。</li>\n<li>GC回收“即将回收”集合中的对象</li>\n</ol>\n<p>ps：JVM只会主动触发一次对象的finalize方法（代码主动触发不计在内）<br>pps：不建议使用该方法</p>\n<p>关于finalize更多资料可查看<a href=\"https://www.cnblogs.com/iamzhoug37/p/4279151.html\" target=\"_blank\" rel=\"noopener\">java的finalize()函数</a>。</p>\n<h2 id=\"方法区-类\"><a href=\"#方法区-类\" class=\"headerlink\" title=\"方法区-类\"></a>方法区-类</h2><p>仅当方法区中的类满足以下3个条件时，可以被回收（不一定被回收）。</p>\n<ol>\n<li>当前类无任何实例</li>\n<li>该类的ClassLoader对象已被回收</li>\n<li>该类的Class对象没有被引用</li>\n</ol>\n<h1 id=\"GC的方法\"><a href=\"#GC的方法\" class=\"headerlink\" title=\"GC的方法\"></a>GC的方法</h1><h2 id=\"垃圾收集算法\"><a href=\"#垃圾收集算法\" class=\"headerlink\" title=\"垃圾收集算法\"></a>垃圾收集算法</h2><h3 id=\"标记-清除（Mark-Sweep）\"><a href=\"#标记-清除（Mark-Sweep）\" class=\"headerlink\" title=\"标记-清除（Mark-Sweep）\"></a>标记-清除（Mark-Sweep）</h3><ul>\n<li>分两阶段：标记-清除</li>\n<li>基础算法</li>\n<li>缺点：效率低，产生空间碎片</li>\n</ul>\n<h3 id=\"复制（Copying）\"><a href=\"#复制（Copying）\" class=\"headerlink\" title=\"复制（Copying）\"></a>复制（Copying）</h3><ul>\n<li>内存分块，其中一块使用完后，把存活对象复制到另一块，并清除当前内存块</li>\n<li>优点：无内存空间碎片</li>\n<li>缺点：内存损耗（必然有某个区域无法使用）</li>\n</ul>\n<h3 id=\"标记-整理（Mark-Compact）\"><a href=\"#标记-整理（Mark-Compact）\" class=\"headerlink\" title=\"标记-整理（Mark-Compact）\"></a>标记-整理（Mark-Compact）</h3><ul>\n<li>标记，将存活的对象向内存的某一端移动，并清除存活对象边界外内存区域</li>\n</ul>\n<h3 id=\"分代收集（Generational-Collection）\"><a href=\"#分代收集（Generational-Collection）\" class=\"headerlink\" title=\"分代收集（Generational Collection）\"></a>分代收集（Generational Collection）</h3><ul>\n<li>根据对象存活周期不同，将内存划分成几块，并采用相应的算法（上述算法的综合实现）</li>\n</ul>\n<h2 id=\"垃圾收集器\"><a href=\"#垃圾收集器\" class=\"headerlink\" title=\"垃圾收集器\"></a>垃圾收集器</h2><p>注：本部分所<em>并发</em>指其他其他用户线程可同时进行。未明确指出并发，则意味其他用户线程必须等待GC线程执行完毕。</p>\n<h3 id=\"Serial\"><a href=\"#Serial\" class=\"headerlink\" title=\"Serial\"></a>Serial</h3><ul>\n<li>算法：复制算法（新生代） 标记-整理（老年代）</li>\n<li>类型：单线程</li>\n<li>特点：简单高效</li>\n<li>缺点：STW时间长</li>\n<li>应用场景：单核处理器、桌面应用</li>\n</ul>\n<h3 id=\"ParNew\"><a href=\"#ParNew\" class=\"headerlink\" title=\"ParNew\"></a>ParNew</h3><ul>\n<li>算法：复制算法（新生代） 标记-整理（老年代）</li>\n<li>类型：多线程（新生代） 单线程（老年代）</li>\n<li>特点：Serial升级版，可与CMS配合使用</li>\n<li>缺点：存在线程交互的开销</li>\n<li>应用场景：默认新生代收集器</li>\n</ul>\n<h3 id=\"Parallel-Scavenge\"><a href=\"#Parallel-Scavenge\" class=\"headerlink\" title=\"Parallel Scavenge\"></a>Parallel Scavenge</h3><ul>\n<li>算法：复制算法</li>\n<li>类型：多线程</li>\n<li>特点：吞吐量（STW占用执行时间比例）可控、参数自适应</li>\n<li>缺点：没有好的可配合使用的老年代收集器</li>\n</ul>\n<h3 id=\"Serial-Old\"><a href=\"#Serial-Old\" class=\"headerlink\" title=\"Serial Old\"></a>Serial Old</h3><ul>\n<li>Serial的老年代收集器</li>\n<li>作为CMS的备选及以前与Parallel配合使用</li>\n</ul>\n<h3 id=\"Parallel-Old\"><a href=\"#Parallel-Old\" class=\"headerlink\" title=\"Parallel Old\"></a>Parallel Old</h3><ul>\n<li>区域：老年代</li>\n<li>算法：标记-整理算法</li>\n<li>类型：多线程</li>\n<li>特点：吞吐量优先</li>\n<li>应用场景：注重吞吐量及CPU敏感的场合</li>\n</ul>\n<h3 id=\"CMS\"><a href=\"#CMS\" class=\"headerlink\" title=\"CMS\"></a>CMS</h3><ul>\n<li>区域：老年代</li>\n<li>算法：标记-清除算法</li>\n<li>特点：注重低回收停顿时间</li>\n<li>应用场景：默认</li>\n<li>过程：<br>&nbsp;&nbsp;&nbsp;&nbsp;初始标记（单线程），可达标记<br>&nbsp;&nbsp;&nbsp;&nbsp;并发标记（单线程，并发），执行GC-ROOT Tracing<br>&nbsp;&nbsp;&nbsp;&nbsp;重新标记（多线程），修正因程序执行变动的对象<br>&nbsp;&nbsp;&nbsp;&nbsp;并发清除（单线程，并发）清除</li>\n<li>缺点：1、CPU占用率高；2、无法清除浮动垃圾；3、产生空间碎片（碎片过多无法存放对向时，会提前触发FULL GC）</li>\n</ul>\n<h3 id=\"G1\"><a href=\"#G1\" class=\"headerlink\" title=\"G1\"></a>G1</h3><ul>\n<li>区域：堆划分的多个独立区域（Region）（新生代及老年代为Region的集合）</li>\n<li>算法：标记-整理算法（整体而言） 复制算法（两个Region之间）</li>\n<li>思想：化整数为零</li>\n<li>特点：并发与并行、分代收集、空间整合、可预测的停顿</li>\n<li>过程：<br>&nbsp;&nbsp;&nbsp;&nbsp;初始标记（单线程）<br>&nbsp;&nbsp;&nbsp;&nbsp;并发标记（单线程，并发）<br>&nbsp;&nbsp;&nbsp;&nbsp;最终标记（多线程）<br>&nbsp;&nbsp;&nbsp;&nbsp;筛选回收（多线程）<br>（将耗时最长的并发标记与用户线程并发执行）</li>\n</ul>\n\n<p>PS：针对G1的Region之间及其他垃圾回收器新生代和老年代之间对象的引用，为避免全堆扫描，会维护一个Remembered Set（G1中每个Refion都由各自的Set），在对引用类型数据进行操作时，判断对象是否在不同的区域中，若是，则通过CardTable把相关引用信息记录到Remembered Set中，并在GC时，把Remembered Set加入GC-Root即可。</p>\n<hr>\n<h1 id=\"对象内存分配策略\"><a href=\"#对象内存分配策略\" class=\"headerlink\" title=\"对象内存分配策略\"></a>对象内存分配策略</h1><p>对象分配策略并非固定，与所用的垃圾收集器及虚拟机参数有关，一般而言，按照以下原则分配</p>\n<h2 id=\"优先分配Eden区\"><a href=\"#优先分配Eden区\" class=\"headerlink\" title=\"优先分配Eden区\"></a>优先分配Eden区</h2><p>对象分配时，将优先分配到Eden区，若Eden区空间不足，会先发起一次Minor GC</p>\n<h2 id=\"大对象直接进入老年代\"><a href=\"#大对象直接进入老年代\" class=\"headerlink\" title=\"大对象直接进入老年代\"></a>大对象直接进入老年代</h2><p>根据虚拟机参数，若对象为大对象，则直接进入老年代</p>\n<h2 id=\"长期存活对象进入老年代\"><a href=\"#长期存活对象进入老年代\" class=\"headerlink\" title=\"长期存活对象进入老年代\"></a>长期存活对象进入老年代</h2><p>默认年龄为15的对象（经过15次Minor GC）的对象将进入老年代</p>\n<h2 id=\"动态年龄判断\"><a href=\"#动态年龄判断\" class=\"headerlink\" title=\"动态年龄判断\"></a>动态年龄判断</h2><p>Survivor空间中相同年龄的对象所占空间总和大于Survivor的一半，则直接进入老年代。</p>\n<h2 id=\"空间分配担保\"><a href=\"#空间分配担保\" class=\"headerlink\" title=\"空间分配担保\"></a>空间分配担保</h2><p>若开启空间分配担保，在Minor GC时，若servivor无法存放存活对象，则淬火对象直接进入老年代。若担保失败，会触发Full GC。</p>\n<h2 id=\"Minor-GC-or-Full-GC\"><a href=\"#Minor-GC-or-Full-GC\" class=\"headerlink\" title=\"Minor GC or Full GC\"></a>Minor GC or Full GC</h2><h3 id=\"Minor-GC\"><a href=\"#Minor-GC\" class=\"headerlink\" title=\"Minor GC\"></a>Minor GC</h3><ol>\n<li>当Eden区满时，触发Minor GC。</li>\n</ol>\n<h3 id=\"Full-GC\"><a href=\"#Full-GC\" class=\"headerlink\" title=\"Full GC\"></a>Full GC</h3><ol>\n<li>调用System.gc时，系统建议执行Full GC，但是不必然执行</li>\n<li>老年代空间不足</li>\n<li>方法区空间不足</li>\n<li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li>\n<li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li>\n</ol>\n<h1 id=\"HotSpot-GC算法实现\"><a href=\"#HotSpot-GC算法实现\" class=\"headerlink\" title=\"HotSpot GC算法实现\"></a>HotSpot GC算法实现</h1><h2 id=\"枚举根节点（可达性分析实现）\"><a href=\"#枚举根节点（可达性分析实现）\" class=\"headerlink\" title=\"枚举根节点（可达性分析实现）\"></a>枚举根节点（可达性分析实现）</h2><p>问题：如何定位对象的哪些位置是引用？  </p>\n<ul>\n<li>解决：使用一组OppMap的数据结构来获取对象引用的位置。  </li>\n<li>原理：在类加载过程中，直接计算出大对象内什么偏移量上时什么数据类型；在JIT编译过程中，在特定位置记录栈和寄存器中哪些位置是引用。GC时即可得知对象引用信息</li>\n</ul>\n<h2 id=\"安全点（解决如何进入GC问题）\"><a href=\"#安全点（解决如何进入GC问题）\" class=\"headerlink\" title=\"安全点（解决如何进入GC问题）\"></a>安全点（解决如何进入GC问题）</h2><p>问题1：为每条指令创建OopMap，需要大量额外空间</p>\n<ul>\n<li>解决：设置安全点（Safepoint），在特定位置才记录OopMap信息。</li>\n<li>设置标准：是否具有让长时间执行的特征（即方法调用、循环跳转、异常跳转等）</li>\n</ul>\n<p>问题2：多线程时如何让所以线程都到安全点</p>\n<ul>\n<li>解决：<br>&nbsp;&nbsp;&nbsp;&nbsp;抢先式中断：先中断所有线程，若由线程不在安全点，则恢复该线程，并让其执行到安全点上。<br>&nbsp;&nbsp;&nbsp;&nbsp;主动式中断：设置一个标志，各个线程轮询，若需中断，则线程自己中断</li>\n</ul>\n<h2 id=\"安全区域（解决线程挂起等待行时无法到达安全点问题）\"><a href=\"#安全区域（解决线程挂起等待行时无法到达安全点问题）\" class=\"headerlink\" title=\"安全区域（解决线程挂起等待行时无法到达安全点问题）\"></a>安全区域（解决线程挂起等待行时无法到达安全点问题）</h2><p>安全区域（Safe Region）指在一段代码片段中，引用关系不再发生变化。线程执行到安全区域时标识自己已经进入安全区域，在发起GC时，即可忽略进入安全区域的线程。</p>\n<hr>\n<p><small>2018-09-12 23:09    Cyalud    Xiamen</small></p>"},{"title":"深入理解JAVA虚拟机（一）  运行时数据区","date":"2018-09-11T12:15:25.000Z","updated":"2018-09-16T03:15:03.788Z","_content":"\nJVM的书过了一遍，写点博客总结记录下，顺便再过第二遍。\n\n<!-- more -->\n\n# About JAVA\n\n* 定义：面向对象 编程语言\n* 特性：1、封装 继承 多态；2、平台无关性（Write Once， Run Anywhere）\n* 引申：由软件及规范形成的技术体系\n\n# About JVM\n\n* 定义：用于计算设备的规范 虚拟的计算机 \n* 用途：执行字节码文件\n* 主流JVM：Sun HotSpot（Sun默认）；BEA JRockit（性能高）；IBM J9（IBM自用较多）  \n\n<small>三个虚拟机的对比请见<https://blog.csdn.net/chenyi8888/article/details/4722410></small>\n\n***\n华丽的分割线\n***\n\n# JAVA运行时数据区\n\n根据[JAVA虚拟机规范（JAVA SE7）](https://docs.oracle.com/javase/specs/index.html)的规定，JAVA运行时内存分以下区域：\n \n{% asset_img RuntimeMemory.png JAVA运行时内存 %}\n\n\n## 程序计数器\n\n* 概念：当前线程执行字节码行号的指示器\n* 用途：用以选取线程需执行的下一字节码（的位置？个人理解）\n* 特性：线程私有（每个线程需由独立的程序计数器，线程执行才不会混乱）\n* 其他：执行JAVA方法时，指向正在执行的JAVA字节码指令地址；执行Native方法时，为undefined；\n* 不会报错\n\n## JAVA虚拟机栈\n\n* 每个方法创建时都会创建一个栈帧（Stack Frame），方法从调用到结束对应栈帧的出栈及入栈\n* 栈帧包含：  \n&nbsp;&nbsp;&nbsp;&nbsp;**局部变量表**：最小单位：slot（32位），通过索引来访问。  \n&nbsp;&nbsp;&nbsp;&nbsp;主要存放1.基本数据类型（boolean、byte、char、short、int、float、long、double）；2.对象引用（对象起始地址、句柄、或其他对象相关位置）；3.returnAddress。  \n&nbsp;&nbsp;&nbsp;&nbsp; **操作数栈**：因JVM没有寄存器，指令是从操作数栈中取得操作数（数据通过压入-弹出进行访问），存储的数据类型与局部变量表一致（但byte、char、short类型入栈会被转成int型）。\n&nbsp;&nbsp;&nbsp;&nbsp;**动态链接**：指向运行时常量池中，该栈帧所属方法的引用（常量池中方法的符号引用），主要为了支持方法调用过程中的动态链接。\n&nbsp;&nbsp;&nbsp;&nbsp;**方法出口**：记录上个方法的计数器信息，供方法正常退出时使用。\n* 栈帧中局部变量表大小在编译后就已经确认\n* 每个栈帧并非完全独立，存在小部分的重叠（操作数栈与局部量表）（个人理解，对应方法的传参，避免多余的复制操作及存储空间占用）\n* 线程私有\n* 会抛出StackOverflowException（栈深超过JVM限定深度），及OutOfMemoryException（动态拓展超过JVM内存）\n\n## 本地方法栈\n\n* 不属于虚拟机规范，用于执行Native方法\n* 与虚拟机栈作用相似\n* HotSpot中，不区分虚拟机栈与本地方法栈（为同一个内存模型区域）\n\n## JAVA堆\n\n* 存储对象实例、数组\n* 线程共享（通过多个线程私有的分配缓冲区（TLAB），确保对象**创建**时内存区域不重叠）\n* GC主要管理区域\n* 基于分代收集算法，可细分为：新生代、老年代;进一步划分为Eden、From Survivor、To Survivor(三者大小比例默认8：1：1，可通过过参数修改）\n* 可处于物理不连续区域，只要逻辑连续即可\n* 会抛出OutOfMemoryException：Java heap space\n\n注：对象实例并非一定需要存放在堆内存中\n\n## 方法区\n\n* 存储被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等。\n* 在HotSpot中，也被称为永久代  \n&nbsp;&nbsp;&nbsp;&nbsp;**JDK1.6及以前版本**，方法区也被称为永久代（原因：为管理方法区内存，将分代收集算法延申至方法区，省去专门编写垃圾回收）内存回收主要针对常量池及类的卸载  \n&nbsp;&nbsp;&nbsp;&nbsp;**JDK1.7**，保留永久代，但字符串常量移动到了Java 堆（Heap）中开辟的一块区域中   \n&nbsp;&nbsp;&nbsp;&nbsp;**JDK1.8——**， 元空间替代了了永久代，将方法区直接放在一个与堆不相连的本地内存区域（元空间） \n* 会抛出OutOfMemoryException：PermGen space\n\n## 运行时常量池\n\n* 存放类编译时期生成的各种1.字面常量（文本字符串、声明为final的常量值）；2.符号引用（类和接口的全限定名、字段名称和描述符、方法名称和描述符）\n* 作用：1.节省内存空间（相同字符串常量被合并，减少空间占用）2.节省运行时间（避免频繁创建及销毁对象）\n* HotSpot中，jdk1,6常量池放在方法区，jdk1.7常量池放在堆内存，jdk1.8放在元空间里面\n\n## 直接内存\n\n* 不属于JAVA运行时数据区，不再JAVA虚拟机规范中\n* 会抛出OutOfMemoryException\n\n## 元空间（JDK1.8，HotSpot）\n\n* 永久代的替代方案\n* 之存放类信息（Classes、Metadata），其他的数据，都被放到到Java堆上\n* 会抛出OutOfMemoryException：Metaspace\n\n## 本地内存（native Memory）\n\nJVM管理的内存可以总体划分为两部分：Heap Memory和Native Memory。Heap Memory 如上所述，可通过参数设置大小。Native Memory没有相应的参数来控制大小，其大小依赖于操作系统进程的最大值（对于32位系统就是3~4G，各种系统的实现并不一样），以及生成的Java字节码大小、创建的线程数量、维持java对象的状态信息大小（用于GC）以及一些第三方的包，比如JDBC驱动使用的native内存。\n\n对于IBM的JVM某些版本实现，类加载器和类信息都是保存在Native Memory中的。\n\n{% asset_img DirectBuffer.png JAVA内存 %}\n\n## 其他\n\n\n\n# HotSpot对象创建\n\n## 普通对象创建过程\n\n当虚拟机遇到new 关键字时\n\n1. 常量池由类的符号引用 && 判断类已加载、解析、初始化？是3：否2；\n2. 加载类（加载-链接（验证-准备-解析）-初始化）\n3. 分配堆内存：指针碰撞（Bump the Pointer）（内存规整时，使用带整理算法的CG收集器如：Seral、ParNew），或空闲列表（FreeList，使用带清除算法的GC收集器，如CMS等）；同时，为保证内存分配的线程安全，可采用TLAB（可不使用），使用TLAB只需在TLAB用完并分配新的TLAB时，才需要同步锁定。\n4. 内存空间初始化（保证对象不赋值就可以直接使用）\n5. 设置对象头（类的元数据信息、对象HASH、GC分代年龄等）\n6. 执行对象的init方法\n\n## 对象内存布局\n\n对象在堆中的存储布局分为3块  \n1. 对象头  \n * 运行时数据：数据长度根据虚拟机的位数的不同，分别为32bit及64bit存放HashCode、GC分代年龄、锁状态等   \n * 类型指针：指向该实例的类元数据  \n2. 实例数据\n * 存放父类及本身定义的各种类型数据\n * 受分配策略（HotSpot中，long/double，int，short/Char，byte，boolean，oop分配到一起）及源码定义顺序影响（父类元素在子类元素之前）\n * 若CompactFields参数为true（默认true），子类较窄的变量可能会插到父类变量中\n3. 对齐填充\n * 不必然存在，HotSpot中，对象的起始地址必须是8字节的整数倍，若对象实例数据不齐时，则需对其填充\n\n## 对象的访问定位\n\n* 句柄访问：在堆中开辟一块内存，作为句柄池，栈中存储句柄地址，句柄存放对象实例及对象类型数据地址信息。优势：稳定。\n* 直接地址：栈中直接指向堆中对象实例地址，对象实例存放对象类型数据地址。优势：快速。\n\n---\n\n疑问1：boolean进栈是什么类型；  \n疑问2：byte类型经过压入、弹出后怎么转成byte。  \n~~疑问3：final static的属性（String，int等）放在哪个区域~~  \n答：运行时常量池\n疑问4：数组相关，数组放哪？怎么引用？怎么初始化？\n疑问5：堆中存放的对象实例，放的是值还是引用符号？或者是什么？怎么知道哪个实际值是对应对象的哪个字段？\n","source":"_posts/2018-09-11-JVM_BASIC_Memory.md","raw":"---\ntitle: 深入理解JAVA虚拟机（一）  运行时数据区\ndate: 2018/9/11 20:15:25\nupdated: \ntag: \n- JVM\n- 内存分配\ncategories:\n- Java\n\n---\n\nJVM的书过了一遍，写点博客总结记录下，顺便再过第二遍。\n\n<!-- more -->\n\n# About JAVA\n\n* 定义：面向对象 编程语言\n* 特性：1、封装 继承 多态；2、平台无关性（Write Once， Run Anywhere）\n* 引申：由软件及规范形成的技术体系\n\n# About JVM\n\n* 定义：用于计算设备的规范 虚拟的计算机 \n* 用途：执行字节码文件\n* 主流JVM：Sun HotSpot（Sun默认）；BEA JRockit（性能高）；IBM J9（IBM自用较多）  \n\n<small>三个虚拟机的对比请见<https://blog.csdn.net/chenyi8888/article/details/4722410></small>\n\n***\n华丽的分割线\n***\n\n# JAVA运行时数据区\n\n根据[JAVA虚拟机规范（JAVA SE7）](https://docs.oracle.com/javase/specs/index.html)的规定，JAVA运行时内存分以下区域：\n \n{% asset_img RuntimeMemory.png JAVA运行时内存 %}\n\n\n## 程序计数器\n\n* 概念：当前线程执行字节码行号的指示器\n* 用途：用以选取线程需执行的下一字节码（的位置？个人理解）\n* 特性：线程私有（每个线程需由独立的程序计数器，线程执行才不会混乱）\n* 其他：执行JAVA方法时，指向正在执行的JAVA字节码指令地址；执行Native方法时，为undefined；\n* 不会报错\n\n## JAVA虚拟机栈\n\n* 每个方法创建时都会创建一个栈帧（Stack Frame），方法从调用到结束对应栈帧的出栈及入栈\n* 栈帧包含：  \n&nbsp;&nbsp;&nbsp;&nbsp;**局部变量表**：最小单位：slot（32位），通过索引来访问。  \n&nbsp;&nbsp;&nbsp;&nbsp;主要存放1.基本数据类型（boolean、byte、char、short、int、float、long、double）；2.对象引用（对象起始地址、句柄、或其他对象相关位置）；3.returnAddress。  \n&nbsp;&nbsp;&nbsp;&nbsp; **操作数栈**：因JVM没有寄存器，指令是从操作数栈中取得操作数（数据通过压入-弹出进行访问），存储的数据类型与局部变量表一致（但byte、char、short类型入栈会被转成int型）。\n&nbsp;&nbsp;&nbsp;&nbsp;**动态链接**：指向运行时常量池中，该栈帧所属方法的引用（常量池中方法的符号引用），主要为了支持方法调用过程中的动态链接。\n&nbsp;&nbsp;&nbsp;&nbsp;**方法出口**：记录上个方法的计数器信息，供方法正常退出时使用。\n* 栈帧中局部变量表大小在编译后就已经确认\n* 每个栈帧并非完全独立，存在小部分的重叠（操作数栈与局部量表）（个人理解，对应方法的传参，避免多余的复制操作及存储空间占用）\n* 线程私有\n* 会抛出StackOverflowException（栈深超过JVM限定深度），及OutOfMemoryException（动态拓展超过JVM内存）\n\n## 本地方法栈\n\n* 不属于虚拟机规范，用于执行Native方法\n* 与虚拟机栈作用相似\n* HotSpot中，不区分虚拟机栈与本地方法栈（为同一个内存模型区域）\n\n## JAVA堆\n\n* 存储对象实例、数组\n* 线程共享（通过多个线程私有的分配缓冲区（TLAB），确保对象**创建**时内存区域不重叠）\n* GC主要管理区域\n* 基于分代收集算法，可细分为：新生代、老年代;进一步划分为Eden、From Survivor、To Survivor(三者大小比例默认8：1：1，可通过过参数修改）\n* 可处于物理不连续区域，只要逻辑连续即可\n* 会抛出OutOfMemoryException：Java heap space\n\n注：对象实例并非一定需要存放在堆内存中\n\n## 方法区\n\n* 存储被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等。\n* 在HotSpot中，也被称为永久代  \n&nbsp;&nbsp;&nbsp;&nbsp;**JDK1.6及以前版本**，方法区也被称为永久代（原因：为管理方法区内存，将分代收集算法延申至方法区，省去专门编写垃圾回收）内存回收主要针对常量池及类的卸载  \n&nbsp;&nbsp;&nbsp;&nbsp;**JDK1.7**，保留永久代，但字符串常量移动到了Java 堆（Heap）中开辟的一块区域中   \n&nbsp;&nbsp;&nbsp;&nbsp;**JDK1.8——**， 元空间替代了了永久代，将方法区直接放在一个与堆不相连的本地内存区域（元空间） \n* 会抛出OutOfMemoryException：PermGen space\n\n## 运行时常量池\n\n* 存放类编译时期生成的各种1.字面常量（文本字符串、声明为final的常量值）；2.符号引用（类和接口的全限定名、字段名称和描述符、方法名称和描述符）\n* 作用：1.节省内存空间（相同字符串常量被合并，减少空间占用）2.节省运行时间（避免频繁创建及销毁对象）\n* HotSpot中，jdk1,6常量池放在方法区，jdk1.7常量池放在堆内存，jdk1.8放在元空间里面\n\n## 直接内存\n\n* 不属于JAVA运行时数据区，不再JAVA虚拟机规范中\n* 会抛出OutOfMemoryException\n\n## 元空间（JDK1.8，HotSpot）\n\n* 永久代的替代方案\n* 之存放类信息（Classes、Metadata），其他的数据，都被放到到Java堆上\n* 会抛出OutOfMemoryException：Metaspace\n\n## 本地内存（native Memory）\n\nJVM管理的内存可以总体划分为两部分：Heap Memory和Native Memory。Heap Memory 如上所述，可通过参数设置大小。Native Memory没有相应的参数来控制大小，其大小依赖于操作系统进程的最大值（对于32位系统就是3~4G，各种系统的实现并不一样），以及生成的Java字节码大小、创建的线程数量、维持java对象的状态信息大小（用于GC）以及一些第三方的包，比如JDBC驱动使用的native内存。\n\n对于IBM的JVM某些版本实现，类加载器和类信息都是保存在Native Memory中的。\n\n{% asset_img DirectBuffer.png JAVA内存 %}\n\n## 其他\n\n\n\n# HotSpot对象创建\n\n## 普通对象创建过程\n\n当虚拟机遇到new 关键字时\n\n1. 常量池由类的符号引用 && 判断类已加载、解析、初始化？是3：否2；\n2. 加载类（加载-链接（验证-准备-解析）-初始化）\n3. 分配堆内存：指针碰撞（Bump the Pointer）（内存规整时，使用带整理算法的CG收集器如：Seral、ParNew），或空闲列表（FreeList，使用带清除算法的GC收集器，如CMS等）；同时，为保证内存分配的线程安全，可采用TLAB（可不使用），使用TLAB只需在TLAB用完并分配新的TLAB时，才需要同步锁定。\n4. 内存空间初始化（保证对象不赋值就可以直接使用）\n5. 设置对象头（类的元数据信息、对象HASH、GC分代年龄等）\n6. 执行对象的init方法\n\n## 对象内存布局\n\n对象在堆中的存储布局分为3块  \n1. 对象头  \n * 运行时数据：数据长度根据虚拟机的位数的不同，分别为32bit及64bit存放HashCode、GC分代年龄、锁状态等   \n * 类型指针：指向该实例的类元数据  \n2. 实例数据\n * 存放父类及本身定义的各种类型数据\n * 受分配策略（HotSpot中，long/double，int，short/Char，byte，boolean，oop分配到一起）及源码定义顺序影响（父类元素在子类元素之前）\n * 若CompactFields参数为true（默认true），子类较窄的变量可能会插到父类变量中\n3. 对齐填充\n * 不必然存在，HotSpot中，对象的起始地址必须是8字节的整数倍，若对象实例数据不齐时，则需对其填充\n\n## 对象的访问定位\n\n* 句柄访问：在堆中开辟一块内存，作为句柄池，栈中存储句柄地址，句柄存放对象实例及对象类型数据地址信息。优势：稳定。\n* 直接地址：栈中直接指向堆中对象实例地址，对象实例存放对象类型数据地址。优势：快速。\n\n---\n\n疑问1：boolean进栈是什么类型；  \n疑问2：byte类型经过压入、弹出后怎么转成byte。  \n~~疑问3：final static的属性（String，int等）放在哪个区域~~  \n答：运行时常量池\n疑问4：数组相关，数组放哪？怎么引用？怎么初始化？\n疑问5：堆中存放的对象实例，放的是值还是引用符号？或者是什么？怎么知道哪个实际值是对应对象的哪个字段？\n","slug":"2018-09-11-JVM_BASIC_Memory","published":1,"_id":"cjm4a7k3o0005dwvjfo0xf846","comments":1,"layout":"post","photos":[],"link":"","content":"<p>JVM的书过了一遍，写点博客总结记录下，顺便再过第二遍。</p>\n<a id=\"more\"></a>\n<h1 id=\"About-JAVA\"><a href=\"#About-JAVA\" class=\"headerlink\" title=\"About JAVA\"></a>About JAVA</h1><ul>\n<li>定义：面向对象 编程语言</li>\n<li>特性：1、封装 继承 多态；2、平台无关性（Write Once， Run Anywhere）</li>\n<li>引申：由软件及规范形成的技术体系</li>\n</ul>\n<h1 id=\"About-JVM\"><a href=\"#About-JVM\" class=\"headerlink\" title=\"About JVM\"></a>About JVM</h1><ul>\n<li>定义：用于计算设备的规范 虚拟的计算机 </li>\n<li>用途：执行字节码文件</li>\n<li>主流JVM：Sun HotSpot（Sun默认）；BEA JRockit（性能高）；IBM J9（IBM自用较多）  </li>\n</ul>\n<p><small>三个虚拟机的对比请见<a href=\"https://blog.csdn.net/chenyi8888/article/details/4722410\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/chenyi8888/article/details/4722410</a></small></p>\n<hr>\n<p>华丽的分割线</p>\n<hr>\n<h1 id=\"JAVA运行时数据区\"><a href=\"#JAVA运行时数据区\" class=\"headerlink\" title=\"JAVA运行时数据区\"></a>JAVA运行时数据区</h1><p>根据<a href=\"https://docs.oracle.com/javase/specs/index.html\" target=\"_blank\" rel=\"noopener\">JAVA虚拟机规范（JAVA SE7）</a>的规定，JAVA运行时内存分以下区域：</p>\n<img src=\"/2018/09/11/2018-09-11-JVM_BASIC_Memory/RuntimeMemory.png\" title=\"JAVA运行时内存\">\n<h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><ul>\n<li>概念：当前线程执行字节码行号的指示器</li>\n<li>用途：用以选取线程需执行的下一字节码（的位置？个人理解）</li>\n<li>特性：线程私有（每个线程需由独立的程序计数器，线程执行才不会混乱）</li>\n<li>其他：执行JAVA方法时，指向正在执行的JAVA字节码指令地址；执行Native方法时，为undefined；</li>\n<li>不会报错</li>\n</ul>\n<h2 id=\"JAVA虚拟机栈\"><a href=\"#JAVA虚拟机栈\" class=\"headerlink\" title=\"JAVA虚拟机栈\"></a>JAVA虚拟机栈</h2><ul>\n<li>每个方法创建时都会创建一个栈帧（Stack Frame），方法从调用到结束对应栈帧的出栈及入栈</li>\n<li>栈帧包含：<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>局部变量表</strong>：最小单位：slot（32位），通过索引来访问。<br>&nbsp;&nbsp;&nbsp;&nbsp;主要存放1.基本数据类型（boolean、byte、char、short、int、float、long、double）；2.对象引用（对象起始地址、句柄、或其他对象相关位置）；3.returnAddress。<br>&nbsp;&nbsp;&nbsp;&nbsp; <strong>操作数栈</strong>：因JVM没有寄存器，指令是从操作数栈中取得操作数（数据通过压入-弹出进行访问），存储的数据类型与局部变量表一致（但byte、char、short类型入栈会被转成int型）。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>动态链接</strong>：指向运行时常量池中，该栈帧所属方法的引用（常量池中方法的符号引用），主要为了支持方法调用过程中的动态链接。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>方法出口</strong>：记录上个方法的计数器信息，供方法正常退出时使用。</li>\n<li>栈帧中局部变量表大小在编译后就已经确认</li>\n<li>每个栈帧并非完全独立，存在小部分的重叠（操作数栈与局部量表）（个人理解，对应方法的传参，避免多余的复制操作及存储空间占用）</li>\n<li>线程私有</li>\n<li>会抛出StackOverflowException（栈深超过JVM限定深度），及OutOfMemoryException（动态拓展超过JVM内存）</li>\n</ul>\n<h2 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h2><ul>\n<li>不属于虚拟机规范，用于执行Native方法</li>\n<li>与虚拟机栈作用相似</li>\n<li>HotSpot中，不区分虚拟机栈与本地方法栈（为同一个内存模型区域）</li>\n</ul>\n<h2 id=\"JAVA堆\"><a href=\"#JAVA堆\" class=\"headerlink\" title=\"JAVA堆\"></a>JAVA堆</h2><ul>\n<li>存储对象实例、数组</li>\n<li>线程共享（通过多个线程私有的分配缓冲区（TLAB），确保对象<strong>创建</strong>时内存区域不重叠）</li>\n<li>GC主要管理区域</li>\n<li>基于分代收集算法，可细分为：新生代、老年代;进一步划分为Eden、From Survivor、To Survivor(三者大小比例默认8：1：1，可通过过参数修改）</li>\n<li>可处于物理不连续区域，只要逻辑连续即可</li>\n<li>会抛出OutOfMemoryException：Java heap space</li>\n</ul>\n<p>注：对象实例并非一定需要存放在堆内存中</p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><ul>\n<li>存储被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等。</li>\n<li>在HotSpot中，也被称为永久代<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>JDK1.6及以前版本</strong>，方法区也被称为永久代（原因：为管理方法区内存，将分代收集算法延申至方法区，省去专门编写垃圾回收）内存回收主要针对常量池及类的卸载<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>JDK1.7</strong>，保留永久代，但字符串常量移动到了Java 堆（Heap）中开辟的一块区域中<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>JDK1.8——</strong>， 元空间替代了了永久代，将方法区直接放在一个与堆不相连的本地内存区域（元空间） </li>\n<li>会抛出OutOfMemoryException：PermGen space</li>\n</ul>\n<h2 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h2><ul>\n<li>存放类编译时期生成的各种1.字面常量（文本字符串、声明为final的常量值）；2.符号引用（类和接口的全限定名、字段名称和描述符、方法名称和描述符）</li>\n<li>作用：1.节省内存空间（相同字符串常量被合并，减少空间占用）2.节省运行时间（避免频繁创建及销毁对象）</li>\n<li>HotSpot中，jdk1,6常量池放在方法区，jdk1.7常量池放在堆内存，jdk1.8放在元空间里面</li>\n</ul>\n<h2 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h2><ul>\n<li>不属于JAVA运行时数据区，不再JAVA虚拟机规范中</li>\n<li>会抛出OutOfMemoryException</li>\n</ul>\n<h2 id=\"元空间（JDK1-8，HotSpot）\"><a href=\"#元空间（JDK1-8，HotSpot）\" class=\"headerlink\" title=\"元空间（JDK1.8，HotSpot）\"></a>元空间（JDK1.8，HotSpot）</h2><ul>\n<li>永久代的替代方案</li>\n<li>之存放类信息（Classes、Metadata），其他的数据，都被放到到Java堆上</li>\n<li>会抛出OutOfMemoryException：Metaspace</li>\n</ul>\n<h2 id=\"本地内存（native-Memory）\"><a href=\"#本地内存（native-Memory）\" class=\"headerlink\" title=\"本地内存（native Memory）\"></a>本地内存（native Memory）</h2><p>JVM管理的内存可以总体划分为两部分：Heap Memory和Native Memory。Heap Memory 如上所述，可通过参数设置大小。Native Memory没有相应的参数来控制大小，其大小依赖于操作系统进程的最大值（对于32位系统就是3~4G，各种系统的实现并不一样），以及生成的Java字节码大小、创建的线程数量、维持java对象的状态信息大小（用于GC）以及一些第三方的包，比如JDBC驱动使用的native内存。</p>\n<p>对于IBM的JVM某些版本实现，类加载器和类信息都是保存在Native Memory中的。</p>\n<img src=\"/2018/09/11/2018-09-11-JVM_BASIC_Memory/DirectBuffer.png\" title=\"JAVA内存\">\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h1 id=\"HotSpot对象创建\"><a href=\"#HotSpot对象创建\" class=\"headerlink\" title=\"HotSpot对象创建\"></a>HotSpot对象创建</h1><h2 id=\"普通对象创建过程\"><a href=\"#普通对象创建过程\" class=\"headerlink\" title=\"普通对象创建过程\"></a>普通对象创建过程</h2><p>当虚拟机遇到new 关键字时</p>\n<ol>\n<li>常量池由类的符号引用 &amp;&amp; 判断类已加载、解析、初始化？是3：否2；</li>\n<li>加载类（加载-链接（验证-准备-解析）-初始化）</li>\n<li>分配堆内存：指针碰撞（Bump the Pointer）（内存规整时，使用带整理算法的CG收集器如：Seral、ParNew），或空闲列表（FreeList，使用带清除算法的GC收集器，如CMS等）；同时，为保证内存分配的线程安全，可采用TLAB（可不使用），使用TLAB只需在TLAB用完并分配新的TLAB时，才需要同步锁定。</li>\n<li>内存空间初始化（保证对象不赋值就可以直接使用）</li>\n<li>设置对象头（类的元数据信息、对象HASH、GC分代年龄等）</li>\n<li>执行对象的init方法</li>\n</ol>\n<h2 id=\"对象内存布局\"><a href=\"#对象内存布局\" class=\"headerlink\" title=\"对象内存布局\"></a>对象内存布局</h2><p>对象在堆中的存储布局分为3块  </p>\n<ol>\n<li>对象头  <ul>\n<li>运行时数据：数据长度根据虚拟机的位数的不同，分别为32bit及64bit存放HashCode、GC分代年龄、锁状态等   </li>\n<li>类型指针：指向该实例的类元数据  </li>\n</ul>\n</li>\n<li>实例数据<ul>\n<li>存放父类及本身定义的各种类型数据</li>\n<li>受分配策略（HotSpot中，long/double，int，short/Char，byte，boolean，oop分配到一起）及源码定义顺序影响（父类元素在子类元素之前）</li>\n<li>若CompactFields参数为true（默认true），子类较窄的变量可能会插到父类变量中</li>\n</ul>\n</li>\n<li>对齐填充<ul>\n<li>不必然存在，HotSpot中，对象的起始地址必须是8字节的整数倍，若对象实例数据不齐时，则需对其填充</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h2><ul>\n<li>句柄访问：在堆中开辟一块内存，作为句柄池，栈中存储句柄地址，句柄存放对象实例及对象类型数据地址信息。优势：稳定。</li>\n<li>直接地址：栈中直接指向堆中对象实例地址，对象实例存放对象类型数据地址。优势：快速。</li>\n</ul>\n<hr>\n<p>疑问1：boolean进栈是什么类型；<br>疑问2：byte类型经过压入、弹出后怎么转成byte。<br><del>疑问3：final static的属性（String，int等）放在哪个区域</del><br>答：运行时常量池<br>疑问4：数组相关，数组放哪？怎么引用？怎么初始化？<br>疑问5：堆中存放的对象实例，放的是值还是引用符号？或者是什么？怎么知道哪个实际值是对应对象的哪个字段？</p>\n","site":{"data":{}},"excerpt":"<p>JVM的书过了一遍，写点博客总结记录下，顺便再过第二遍。</p>","more":"<h1 id=\"About-JAVA\"><a href=\"#About-JAVA\" class=\"headerlink\" title=\"About JAVA\"></a>About JAVA</h1><ul>\n<li>定义：面向对象 编程语言</li>\n<li>特性：1、封装 继承 多态；2、平台无关性（Write Once， Run Anywhere）</li>\n<li>引申：由软件及规范形成的技术体系</li>\n</ul>\n<h1 id=\"About-JVM\"><a href=\"#About-JVM\" class=\"headerlink\" title=\"About JVM\"></a>About JVM</h1><ul>\n<li>定义：用于计算设备的规范 虚拟的计算机 </li>\n<li>用途：执行字节码文件</li>\n<li>主流JVM：Sun HotSpot（Sun默认）；BEA JRockit（性能高）；IBM J9（IBM自用较多）  </li>\n</ul>\n<p><small>三个虚拟机的对比请见<a href=\"https://blog.csdn.net/chenyi8888/article/details/4722410\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/chenyi8888/article/details/4722410</a></small></p>\n<hr>\n<p>华丽的分割线</p>\n<hr>\n<h1 id=\"JAVA运行时数据区\"><a href=\"#JAVA运行时数据区\" class=\"headerlink\" title=\"JAVA运行时数据区\"></a>JAVA运行时数据区</h1><p>根据<a href=\"https://docs.oracle.com/javase/specs/index.html\" target=\"_blank\" rel=\"noopener\">JAVA虚拟机规范（JAVA SE7）</a>的规定，JAVA运行时内存分以下区域：</p>\n<img src=\"/2018/09/11/2018-09-11-JVM_BASIC_Memory/RuntimeMemory.png\" title=\"JAVA运行时内存\">\n<h2 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h2><ul>\n<li>概念：当前线程执行字节码行号的指示器</li>\n<li>用途：用以选取线程需执行的下一字节码（的位置？个人理解）</li>\n<li>特性：线程私有（每个线程需由独立的程序计数器，线程执行才不会混乱）</li>\n<li>其他：执行JAVA方法时，指向正在执行的JAVA字节码指令地址；执行Native方法时，为undefined；</li>\n<li>不会报错</li>\n</ul>\n<h2 id=\"JAVA虚拟机栈\"><a href=\"#JAVA虚拟机栈\" class=\"headerlink\" title=\"JAVA虚拟机栈\"></a>JAVA虚拟机栈</h2><ul>\n<li>每个方法创建时都会创建一个栈帧（Stack Frame），方法从调用到结束对应栈帧的出栈及入栈</li>\n<li>栈帧包含：<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>局部变量表</strong>：最小单位：slot（32位），通过索引来访问。<br>&nbsp;&nbsp;&nbsp;&nbsp;主要存放1.基本数据类型（boolean、byte、char、short、int、float、long、double）；2.对象引用（对象起始地址、句柄、或其他对象相关位置）；3.returnAddress。<br>&nbsp;&nbsp;&nbsp;&nbsp; <strong>操作数栈</strong>：因JVM没有寄存器，指令是从操作数栈中取得操作数（数据通过压入-弹出进行访问），存储的数据类型与局部变量表一致（但byte、char、short类型入栈会被转成int型）。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>动态链接</strong>：指向运行时常量池中，该栈帧所属方法的引用（常量池中方法的符号引用），主要为了支持方法调用过程中的动态链接。<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>方法出口</strong>：记录上个方法的计数器信息，供方法正常退出时使用。</li>\n<li>栈帧中局部变量表大小在编译后就已经确认</li>\n<li>每个栈帧并非完全独立，存在小部分的重叠（操作数栈与局部量表）（个人理解，对应方法的传参，避免多余的复制操作及存储空间占用）</li>\n<li>线程私有</li>\n<li>会抛出StackOverflowException（栈深超过JVM限定深度），及OutOfMemoryException（动态拓展超过JVM内存）</li>\n</ul>\n<h2 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h2><ul>\n<li>不属于虚拟机规范，用于执行Native方法</li>\n<li>与虚拟机栈作用相似</li>\n<li>HotSpot中，不区分虚拟机栈与本地方法栈（为同一个内存模型区域）</li>\n</ul>\n<h2 id=\"JAVA堆\"><a href=\"#JAVA堆\" class=\"headerlink\" title=\"JAVA堆\"></a>JAVA堆</h2><ul>\n<li>存储对象实例、数组</li>\n<li>线程共享（通过多个线程私有的分配缓冲区（TLAB），确保对象<strong>创建</strong>时内存区域不重叠）</li>\n<li>GC主要管理区域</li>\n<li>基于分代收集算法，可细分为：新生代、老年代;进一步划分为Eden、From Survivor、To Survivor(三者大小比例默认8：1：1，可通过过参数修改）</li>\n<li>可处于物理不连续区域，只要逻辑连续即可</li>\n<li>会抛出OutOfMemoryException：Java heap space</li>\n</ul>\n<p>注：对象实例并非一定需要存放在堆内存中</p>\n<h2 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h2><ul>\n<li>存储被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等。</li>\n<li>在HotSpot中，也被称为永久代<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>JDK1.6及以前版本</strong>，方法区也被称为永久代（原因：为管理方法区内存，将分代收集算法延申至方法区，省去专门编写垃圾回收）内存回收主要针对常量池及类的卸载<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>JDK1.7</strong>，保留永久代，但字符串常量移动到了Java 堆（Heap）中开辟的一块区域中<br>&nbsp;&nbsp;&nbsp;&nbsp;<strong>JDK1.8——</strong>， 元空间替代了了永久代，将方法区直接放在一个与堆不相连的本地内存区域（元空间） </li>\n<li>会抛出OutOfMemoryException：PermGen space</li>\n</ul>\n<h2 id=\"运行时常量池\"><a href=\"#运行时常量池\" class=\"headerlink\" title=\"运行时常量池\"></a>运行时常量池</h2><ul>\n<li>存放类编译时期生成的各种1.字面常量（文本字符串、声明为final的常量值）；2.符号引用（类和接口的全限定名、字段名称和描述符、方法名称和描述符）</li>\n<li>作用：1.节省内存空间（相同字符串常量被合并，减少空间占用）2.节省运行时间（避免频繁创建及销毁对象）</li>\n<li>HotSpot中，jdk1,6常量池放在方法区，jdk1.7常量池放在堆内存，jdk1.8放在元空间里面</li>\n</ul>\n<h2 id=\"直接内存\"><a href=\"#直接内存\" class=\"headerlink\" title=\"直接内存\"></a>直接内存</h2><ul>\n<li>不属于JAVA运行时数据区，不再JAVA虚拟机规范中</li>\n<li>会抛出OutOfMemoryException</li>\n</ul>\n<h2 id=\"元空间（JDK1-8，HotSpot）\"><a href=\"#元空间（JDK1-8，HotSpot）\" class=\"headerlink\" title=\"元空间（JDK1.8，HotSpot）\"></a>元空间（JDK1.8，HotSpot）</h2><ul>\n<li>永久代的替代方案</li>\n<li>之存放类信息（Classes、Metadata），其他的数据，都被放到到Java堆上</li>\n<li>会抛出OutOfMemoryException：Metaspace</li>\n</ul>\n<h2 id=\"本地内存（native-Memory）\"><a href=\"#本地内存（native-Memory）\" class=\"headerlink\" title=\"本地内存（native Memory）\"></a>本地内存（native Memory）</h2><p>JVM管理的内存可以总体划分为两部分：Heap Memory和Native Memory。Heap Memory 如上所述，可通过参数设置大小。Native Memory没有相应的参数来控制大小，其大小依赖于操作系统进程的最大值（对于32位系统就是3~4G，各种系统的实现并不一样），以及生成的Java字节码大小、创建的线程数量、维持java对象的状态信息大小（用于GC）以及一些第三方的包，比如JDBC驱动使用的native内存。</p>\n<p>对于IBM的JVM某些版本实现，类加载器和类信息都是保存在Native Memory中的。</p>\n<img src=\"/2018/09/11/2018-09-11-JVM_BASIC_Memory/DirectBuffer.png\" title=\"JAVA内存\">\n<h2 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h2><h1 id=\"HotSpot对象创建\"><a href=\"#HotSpot对象创建\" class=\"headerlink\" title=\"HotSpot对象创建\"></a>HotSpot对象创建</h1><h2 id=\"普通对象创建过程\"><a href=\"#普通对象创建过程\" class=\"headerlink\" title=\"普通对象创建过程\"></a>普通对象创建过程</h2><p>当虚拟机遇到new 关键字时</p>\n<ol>\n<li>常量池由类的符号引用 &amp;&amp; 判断类已加载、解析、初始化？是3：否2；</li>\n<li>加载类（加载-链接（验证-准备-解析）-初始化）</li>\n<li>分配堆内存：指针碰撞（Bump the Pointer）（内存规整时，使用带整理算法的CG收集器如：Seral、ParNew），或空闲列表（FreeList，使用带清除算法的GC收集器，如CMS等）；同时，为保证内存分配的线程安全，可采用TLAB（可不使用），使用TLAB只需在TLAB用完并分配新的TLAB时，才需要同步锁定。</li>\n<li>内存空间初始化（保证对象不赋值就可以直接使用）</li>\n<li>设置对象头（类的元数据信息、对象HASH、GC分代年龄等）</li>\n<li>执行对象的init方法</li>\n</ol>\n<h2 id=\"对象内存布局\"><a href=\"#对象内存布局\" class=\"headerlink\" title=\"对象内存布局\"></a>对象内存布局</h2><p>对象在堆中的存储布局分为3块  </p>\n<ol>\n<li>对象头  <ul>\n<li>运行时数据：数据长度根据虚拟机的位数的不同，分别为32bit及64bit存放HashCode、GC分代年龄、锁状态等   </li>\n<li>类型指针：指向该实例的类元数据  </li>\n</ul>\n</li>\n<li>实例数据<ul>\n<li>存放父类及本身定义的各种类型数据</li>\n<li>受分配策略（HotSpot中，long/double，int，short/Char，byte，boolean，oop分配到一起）及源码定义顺序影响（父类元素在子类元素之前）</li>\n<li>若CompactFields参数为true（默认true），子类较窄的变量可能会插到父类变量中</li>\n</ul>\n</li>\n<li>对齐填充<ul>\n<li>不必然存在，HotSpot中，对象的起始地址必须是8字节的整数倍，若对象实例数据不齐时，则需对其填充</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"对象的访问定位\"><a href=\"#对象的访问定位\" class=\"headerlink\" title=\"对象的访问定位\"></a>对象的访问定位</h2><ul>\n<li>句柄访问：在堆中开辟一块内存，作为句柄池，栈中存储句柄地址，句柄存放对象实例及对象类型数据地址信息。优势：稳定。</li>\n<li>直接地址：栈中直接指向堆中对象实例地址，对象实例存放对象类型数据地址。优势：快速。</li>\n</ul>\n<hr>\n<p>疑问1：boolean进栈是什么类型；<br>疑问2：byte类型经过压入、弹出后怎么转成byte。<br><del>疑问3：final static的属性（String，int等）放在哪个区域</del><br>答：运行时常量池<br>疑问4：数组相关，数组放哪？怎么引用？怎么初始化？<br>疑问5：堆中存放的对象实例，放的是值还是引用符号？或者是什么？怎么知道哪个实际值是对应对象的哪个字段？</p>"},{"title":"深入理解JAVA虚拟机（三）  CLASS文件结构","date":"2018-09-13T12:02:13.000Z","updated":"2018-09-16T03:14:54.235Z","_content":"\nJAVA语言以及其他运行于JVM上的语言（JRuby、Groovy等）中所定义各种变量、逻辑，通过不同的编译器最终都会被转成字节码文件用于虚拟机执行，甚至一些Java语言无法支持的特性，字节码文件都可以支持，可以看出，字节码文件的重要性。\n\n<!-- more -->\n\n# 概述\n\n本质：由一组**8位**字节，严格**按照顺序**，**紧凑**排列组成的**二进制流**。\n* 8位：CLASS文件的基础单位，超过8为的数据在存放时采用***高位在前***的存储方式存储。\nps：高位在前指的时最高的字节在地址的低位（即访问时先访问到）\n* 按照顺序：按照虚拟机规范中对字节码文件的定义\n* 紧凑：各数据之间没有任何分隔符\n* 二进制流：只要时符合规范的二进制流虚拟机都可识别，也就意味着**CLASS文件的来源不局限于文件系统**。\n\n数据结构：采用了**无符号数**和**表**这两种伪结构存储数据。  \n* 无符号数：基本数据类型，以u1、u2、u4和u8分别对应1字节、2字节、4字节和8字节，用以描述数字、索引引用、数量值或UTF-8字符串等。  \n* 表：由多个无符号数或其他数据项构成，习惯以_info结尾。用以描述由层次关系的复合结构数据。 \n* 集合（拓展）：用来描述多个连续的无符号数或表，通常会带一个前置容量计数器\n\n# 字节码文件结构\n\n## 结构概览\n\n| 类型 | 名称 | 数量 | 说明 |\n|:--:|:--|:--:|:--|\n| u4 | 魔数（magic） | 1 |   |\n| u2 | 次版本号（minor_version） | 1 |   |\n| u2 | 主版本号（major_version） | 1 |   |\n| u2 | 常量池常量数（constant_pool_count） | 1 | 与constant_pool构成一个表的集合 |\n| cp_info | 常量池（constant_pool） |  常量池常量数| 每个常量都是一个表，存放放量相关信息 |\n| u2 | 权限标志（access flags） | 1 |  |\n| u2 | 本类名（this_class） | 1 | 指向常量池中本类的全限定名字符串的索引（第几个） |\n| u2 | 父类名（this_class） | 1 | 指向常量池中父类的全限定名字符串的索引 |\n| u2 | 接口数量（interfaces_count） | 1 | 与interfaces组成一个u2的无符号集合 |\n| u2 | 接口（interfaces） | 接口数量 | 指向常量池中接口的全限定名字符串的索引 |\n| u2 | 字段数量（filed_count） | 1 | 与filed_info组成字段集合 |\n| filed_info | 字段（filed） | 字段数量 | 数据结构较复杂 |\n| u2 | 方法数量（method_info） | 1 | 与method_info组成方法集合 |\n| method_info | 方法（method） | 方法数量 | 数据结构较复杂 |\n| u2 | 属性数量（attribute_count） | 1 | 与attribute_info组成属性集合 |\n| attribute_info | 属性（attribute） | 属性数量 | 数据结构较复杂 |\n\n## 魔数（u4）\n\n固定值：CA FE BA BE \n用以标识当前文件是给JVM执行的字节码文件\n\n## 次版本号（u2）\n\n标识CLASS文件的次版本号\n\n## 主版本号（u2）\n\n标识CLASS文件的主版本号（JVM执行的版本，非实际JAVA开发版本），从JAVA1.1 到JAVA1.8 分别对应从 45 到 52。\n\n## 常量池常量数（u2）及常量池（cp_info）\n\n### 常量池常量数\n\n* 索引从1开始，即实际常量数是=常量池常量数-1\n* 索引0主要是为了“表示不引用任何常量池常量”\n\n### 常量池\n\n常量池主要存放：字面量和符号引用\n* 字面量：文本字符串、声明为final的常量值。\n* 符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符\n\n全限定名：表示类的路径及名称；如\"java/lang/Object;\"，一般以；标识全限定名的结束。\n简单名称：标识字段及方法的名称，如字段x，方法int()对应的就是\"x，int\"\n描述符：描述字段或方法；如\"[Ljava/lang/Object\"表示Object[]；\"(C[I)V\"表示返回值为void，参数为（char，int[]）的方法，诸如此类。\n\n描述符含义\n* B &nbsp;&nbsp;&nbsp;&nbsp; byte\n* C &nbsp;&nbsp;&nbsp;&nbsp; char\n* D &nbsp;&nbsp;&nbsp;&nbsp; double\n* F &nbsp;&nbsp;&nbsp;&nbsp; float\n* I &nbsp;&nbsp;&nbsp;&nbsp; int\n* ***J*** &nbsp;&nbsp;&nbsp;&nbsp; long\n* S &nbsp;&nbsp;&nbsp;&nbsp; short\n* ***Z*** &nbsp;&nbsp;&nbsp;&nbsp; boolean\n* L &nbsp;&nbsp;&nbsp;&nbsp; 对象\n* [ &nbsp;&nbsp;&nbsp;&nbsp; 数组，有多个则代表多维，数组类型为[后紧接的描述符\n* ()  &nbsp;&nbsp;&nbsp; 方法，括号外为返回值类型，括号内为参数类型（各参数之间无逗号） \n\n常量池中，根据常量类型的不同，其具体的表数据结构也略有不同，待后续整理，具体请参阅[JAVA虚拟机规范-4.4章节](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4)。\n\nps：因常量池UTF8字符长度的限制，方法最长长度不能大于65535。\n\n## 访问标志（u2）\n\n表示当前类的访问标志，共可设置16种标志，各标志含义如下\n\n|编号|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|\n|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n|0x|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|\n\n|编号|标志名称|标志值|含义|\n|:--|:--|:--|:--|\n|1|ACC_PUBLIC|0x0001|是否为public类型|\n|5|ACC_FINAL|0x0010|是否为final类型，只有类才可设置|\n|6|ACC_SUPER|0x0020|改之在1.02后必须为1|\n|10|ACC_INTERFACE|0x0200|是否为接口|\n|11|ACC_ABSTRACT|0x0400|是否为抽象类型，对于接口及抽象类，值为真，其他为假|\n|13|ACC_SYNTHETIC|0x1000|这个类不是由用户代码生成（动态标志）|\n|14|ACC_ANNOTATION|0x2000|是否为注解|\n|15|ACC_ENUM|0x4000|是否为枚举类|\n\n## 本类名（u2）\n\n指向常量池中，类型为CONSTANT_Class_info的常量索引（tag为7）。\n\n## 父类名（u2）\n\n指向常量池中，类型为CONSTANT_Class_info的常量索引（tag为7）。\n除了Object外，所有的类的父类索引都不为0（因为所有类都继承自Object）\n\n## 接口集合\n\n### 接口数量（u2）\n\n标识当前类实现的接口的数量\n\n### 接口（u2）\n\n指向常量池中，类型为CONSTANT_Class_info的常量索引（tag为7）。\n若类实现多个接口，则按类实现顺序，从左向右一次放入接口集合中。\n\n## 字段表集合\n\n1、字段集合中不会有从父类或父接口中继承来的字段。但可能会出现代码中没有的字段。\n2、对于字节码而言，只要字段的描述不以相同，即使字段简单名称相同，也会被认为是不同的字段，而JAVA中简单名称必须不同。\n\n### 字段数量（u2）\n\n类或接口中，类级变量及实例级变量的数量（**不包括方法内部声明的变量**）。\n\n### 字段表\n\n字段表主要包含\n1. u2 字段权限标志（access_flags）\n2. u2 字段名对应的简单名称在常量池中的索引(name_index)\n3. u2 字段描述对应的描述符在常量池中索引(descript_index)\n4. u2 属性表数量（attribute_count）\n4. attribute_info 属性表信息（attributet）\n\n其中\n1.字段权限标志，参照如下表\n|编号|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|\n|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n|0x|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|\n\n|编号|标志名称|标志值|含义|\n|:--|:--|:--|:--|\n|1|ACC_PUBLIC|0x0001|是否为public类型|\n|2|ACC_PRIVATE|0x0002|是否为private类型|\n|3|ACC_PROTECTED|0x0004|是否为protected类型|\n|4|ACC_STATIC|0x0008|是否为static|\n|5|ACC_FINAL|0x0010|是否为final型|\n|7|ACC_VOLATILE|0x0040|是否为volatile|\n|8|ACC_TRANSIENT|0x0080|是否为transient|\n|13|ACC_SYNTHETIC|0x1000|是否由编译器生成|\n|15|ACC_ENUM|0x4000|是否为enum|\n\n其中1、2、3最多只能1个为真；5、7不能同时为真；接口中的字段1、4、5必须为真\n\n## 方法集合\n\n1、方法集合中不会出现没有被重写（override）的父类或父接口方法。但可能会出现代码中没有的方法（典型的如类构造器<clinit> 及初始化方法<init>）。\n2、对于字节码而言，只要字段的描述不以相同，即使字段简单名称相同，也会被认为是不同的字段，而JAVA中简单名称必须不同。\n\n### 方法数量（u2）\n\n类或接口中，方法的数量。\n\n### 方法表\n\n方法表主要包含\n1. u2 方法权限标志（access_flags）\n2. u2 方法名对应的简单名称在常量池中的索引(name_index)\n3. u2 方法描述对应的描述符在常量池中索引(descript_index)\n4. u2 属性表数量（attribute_count）\n4. attribute_info 属性表信息（attributet）\n\n其中\n1.字段权限标志，参照如下表\n|编号|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|\n|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n|0x|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|\n\n|编号|标志名称|标志值|含义|\n|:--|:--|:--|:--|\n|1|ACC_PUBLIC|0x0001|是否为public类型|\n|2|ACC_PRIVATE|0x0002|是否为private类型|\n|3|ACC_PROTECTED|0x0004|是否为protected类型|\n|4|ACC_STATIC|0x0008|是否为static|\n|5|ACC_FINAL|0x0010|是否为final型|\n|6|ACC_SYNCHRONIZED|0x0020|是否为synchronized|\n|7|ACC_BRIDGE|0x0040|是否编译器生成的桥接方法|\n|8|ACC_VARIGES|0x0080|是否接受不定参数|\n|9|ACC_NATIVE|0x010|是否本地方法|\n|11|ACC_ABSTRACT|0x0400|是否抽象方法|\n|12|ACC_STRICTFP|0x0800|是否为strictfp|\n|11|ACC_SYNTHETIC|0x0400|是否由编译器自动产生|\n\n## 属性集合\n\n属性表集合用以描述某些场景的专有信息，CLASS、FILED、METHOD都有携带自己的属性表集合。\n\n### 属性数量（u2）\n\n描述当前属性表的属性数量\n\n### 属性表\n\n属性表至少需包含以下（各类属性表结构略有区别）；\n\n1. u2 属性名对应的简单名称在常量池中的索引(attribute_name_index)\n2. u4 属性长度(attribute_length)\n4. u1 属性表信息（长度为属性长度）\n\n\n属性的描述，在JDK1.7时共有21中属性分类。\n\n根据属性类型的不同，其具体的表数据结构也略有不同，具体请参阅[JAVA虚拟机规范-4.7章节](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7)。\n\nps：属性的CODE类型中，虽规定CODE的长度为u4，但实际指令最长长度不能大于65535。\n\n\n\n\n疑问1：在类中，类的静态变量赋值时（如static a = 1;），“1”这个值存放位置。\n答：作为指令，存放在CLASS的属性表中\n疑问2：对象实例的this，在字节码文件中是否有安排位置存放；\n疑问3：桥接方法？\n疑问4：不定参数的方法描述？\n","source":"_posts/2018-09-13-JVM_CLASS.md","raw":"---\ntitle: 深入理解JAVA虚拟机（三）  CLASS文件结构\ndate: 2018/09/13 20:02:13\nupdated: \ntag: \n- JVM\n- 字节码\ncategories:\n- Java\n\n---\n\nJAVA语言以及其他运行于JVM上的语言（JRuby、Groovy等）中所定义各种变量、逻辑，通过不同的编译器最终都会被转成字节码文件用于虚拟机执行，甚至一些Java语言无法支持的特性，字节码文件都可以支持，可以看出，字节码文件的重要性。\n\n<!-- more -->\n\n# 概述\n\n本质：由一组**8位**字节，严格**按照顺序**，**紧凑**排列组成的**二进制流**。\n* 8位：CLASS文件的基础单位，超过8为的数据在存放时采用***高位在前***的存储方式存储。\nps：高位在前指的时最高的字节在地址的低位（即访问时先访问到）\n* 按照顺序：按照虚拟机规范中对字节码文件的定义\n* 紧凑：各数据之间没有任何分隔符\n* 二进制流：只要时符合规范的二进制流虚拟机都可识别，也就意味着**CLASS文件的来源不局限于文件系统**。\n\n数据结构：采用了**无符号数**和**表**这两种伪结构存储数据。  \n* 无符号数：基本数据类型，以u1、u2、u4和u8分别对应1字节、2字节、4字节和8字节，用以描述数字、索引引用、数量值或UTF-8字符串等。  \n* 表：由多个无符号数或其他数据项构成，习惯以_info结尾。用以描述由层次关系的复合结构数据。 \n* 集合（拓展）：用来描述多个连续的无符号数或表，通常会带一个前置容量计数器\n\n# 字节码文件结构\n\n## 结构概览\n\n| 类型 | 名称 | 数量 | 说明 |\n|:--:|:--|:--:|:--|\n| u4 | 魔数（magic） | 1 |   |\n| u2 | 次版本号（minor_version） | 1 |   |\n| u2 | 主版本号（major_version） | 1 |   |\n| u2 | 常量池常量数（constant_pool_count） | 1 | 与constant_pool构成一个表的集合 |\n| cp_info | 常量池（constant_pool） |  常量池常量数| 每个常量都是一个表，存放放量相关信息 |\n| u2 | 权限标志（access flags） | 1 |  |\n| u2 | 本类名（this_class） | 1 | 指向常量池中本类的全限定名字符串的索引（第几个） |\n| u2 | 父类名（this_class） | 1 | 指向常量池中父类的全限定名字符串的索引 |\n| u2 | 接口数量（interfaces_count） | 1 | 与interfaces组成一个u2的无符号集合 |\n| u2 | 接口（interfaces） | 接口数量 | 指向常量池中接口的全限定名字符串的索引 |\n| u2 | 字段数量（filed_count） | 1 | 与filed_info组成字段集合 |\n| filed_info | 字段（filed） | 字段数量 | 数据结构较复杂 |\n| u2 | 方法数量（method_info） | 1 | 与method_info组成方法集合 |\n| method_info | 方法（method） | 方法数量 | 数据结构较复杂 |\n| u2 | 属性数量（attribute_count） | 1 | 与attribute_info组成属性集合 |\n| attribute_info | 属性（attribute） | 属性数量 | 数据结构较复杂 |\n\n## 魔数（u4）\n\n固定值：CA FE BA BE \n用以标识当前文件是给JVM执行的字节码文件\n\n## 次版本号（u2）\n\n标识CLASS文件的次版本号\n\n## 主版本号（u2）\n\n标识CLASS文件的主版本号（JVM执行的版本，非实际JAVA开发版本），从JAVA1.1 到JAVA1.8 分别对应从 45 到 52。\n\n## 常量池常量数（u2）及常量池（cp_info）\n\n### 常量池常量数\n\n* 索引从1开始，即实际常量数是=常量池常量数-1\n* 索引0主要是为了“表示不引用任何常量池常量”\n\n### 常量池\n\n常量池主要存放：字面量和符号引用\n* 字面量：文本字符串、声明为final的常量值。\n* 符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符\n\n全限定名：表示类的路径及名称；如\"java/lang/Object;\"，一般以；标识全限定名的结束。\n简单名称：标识字段及方法的名称，如字段x，方法int()对应的就是\"x，int\"\n描述符：描述字段或方法；如\"[Ljava/lang/Object\"表示Object[]；\"(C[I)V\"表示返回值为void，参数为（char，int[]）的方法，诸如此类。\n\n描述符含义\n* B &nbsp;&nbsp;&nbsp;&nbsp; byte\n* C &nbsp;&nbsp;&nbsp;&nbsp; char\n* D &nbsp;&nbsp;&nbsp;&nbsp; double\n* F &nbsp;&nbsp;&nbsp;&nbsp; float\n* I &nbsp;&nbsp;&nbsp;&nbsp; int\n* ***J*** &nbsp;&nbsp;&nbsp;&nbsp; long\n* S &nbsp;&nbsp;&nbsp;&nbsp; short\n* ***Z*** &nbsp;&nbsp;&nbsp;&nbsp; boolean\n* L &nbsp;&nbsp;&nbsp;&nbsp; 对象\n* [ &nbsp;&nbsp;&nbsp;&nbsp; 数组，有多个则代表多维，数组类型为[后紧接的描述符\n* ()  &nbsp;&nbsp;&nbsp; 方法，括号外为返回值类型，括号内为参数类型（各参数之间无逗号） \n\n常量池中，根据常量类型的不同，其具体的表数据结构也略有不同，待后续整理，具体请参阅[JAVA虚拟机规范-4.4章节](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4)。\n\nps：因常量池UTF8字符长度的限制，方法最长长度不能大于65535。\n\n## 访问标志（u2）\n\n表示当前类的访问标志，共可设置16种标志，各标志含义如下\n\n|编号|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|\n|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n|0x|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|\n\n|编号|标志名称|标志值|含义|\n|:--|:--|:--|:--|\n|1|ACC_PUBLIC|0x0001|是否为public类型|\n|5|ACC_FINAL|0x0010|是否为final类型，只有类才可设置|\n|6|ACC_SUPER|0x0020|改之在1.02后必须为1|\n|10|ACC_INTERFACE|0x0200|是否为接口|\n|11|ACC_ABSTRACT|0x0400|是否为抽象类型，对于接口及抽象类，值为真，其他为假|\n|13|ACC_SYNTHETIC|0x1000|这个类不是由用户代码生成（动态标志）|\n|14|ACC_ANNOTATION|0x2000|是否为注解|\n|15|ACC_ENUM|0x4000|是否为枚举类|\n\n## 本类名（u2）\n\n指向常量池中，类型为CONSTANT_Class_info的常量索引（tag为7）。\n\n## 父类名（u2）\n\n指向常量池中，类型为CONSTANT_Class_info的常量索引（tag为7）。\n除了Object外，所有的类的父类索引都不为0（因为所有类都继承自Object）\n\n## 接口集合\n\n### 接口数量（u2）\n\n标识当前类实现的接口的数量\n\n### 接口（u2）\n\n指向常量池中，类型为CONSTANT_Class_info的常量索引（tag为7）。\n若类实现多个接口，则按类实现顺序，从左向右一次放入接口集合中。\n\n## 字段表集合\n\n1、字段集合中不会有从父类或父接口中继承来的字段。但可能会出现代码中没有的字段。\n2、对于字节码而言，只要字段的描述不以相同，即使字段简单名称相同，也会被认为是不同的字段，而JAVA中简单名称必须不同。\n\n### 字段数量（u2）\n\n类或接口中，类级变量及实例级变量的数量（**不包括方法内部声明的变量**）。\n\n### 字段表\n\n字段表主要包含\n1. u2 字段权限标志（access_flags）\n2. u2 字段名对应的简单名称在常量池中的索引(name_index)\n3. u2 字段描述对应的描述符在常量池中索引(descript_index)\n4. u2 属性表数量（attribute_count）\n4. attribute_info 属性表信息（attributet）\n\n其中\n1.字段权限标志，参照如下表\n|编号|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|\n|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n|0x|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|\n\n|编号|标志名称|标志值|含义|\n|:--|:--|:--|:--|\n|1|ACC_PUBLIC|0x0001|是否为public类型|\n|2|ACC_PRIVATE|0x0002|是否为private类型|\n|3|ACC_PROTECTED|0x0004|是否为protected类型|\n|4|ACC_STATIC|0x0008|是否为static|\n|5|ACC_FINAL|0x0010|是否为final型|\n|7|ACC_VOLATILE|0x0040|是否为volatile|\n|8|ACC_TRANSIENT|0x0080|是否为transient|\n|13|ACC_SYNTHETIC|0x1000|是否由编译器生成|\n|15|ACC_ENUM|0x4000|是否为enum|\n\n其中1、2、3最多只能1个为真；5、7不能同时为真；接口中的字段1、4、5必须为真\n\n## 方法集合\n\n1、方法集合中不会出现没有被重写（override）的父类或父接口方法。但可能会出现代码中没有的方法（典型的如类构造器<clinit> 及初始化方法<init>）。\n2、对于字节码而言，只要字段的描述不以相同，即使字段简单名称相同，也会被认为是不同的字段，而JAVA中简单名称必须不同。\n\n### 方法数量（u2）\n\n类或接口中，方法的数量。\n\n### 方法表\n\n方法表主要包含\n1. u2 方法权限标志（access_flags）\n2. u2 方法名对应的简单名称在常量池中的索引(name_index)\n3. u2 方法描述对应的描述符在常量池中索引(descript_index)\n4. u2 属性表数量（attribute_count）\n4. attribute_info 属性表信息（attributet）\n\n其中\n1.字段权限标志，参照如下表\n|编号|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|\n|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|\n|0x|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|\n\n|编号|标志名称|标志值|含义|\n|:--|:--|:--|:--|\n|1|ACC_PUBLIC|0x0001|是否为public类型|\n|2|ACC_PRIVATE|0x0002|是否为private类型|\n|3|ACC_PROTECTED|0x0004|是否为protected类型|\n|4|ACC_STATIC|0x0008|是否为static|\n|5|ACC_FINAL|0x0010|是否为final型|\n|6|ACC_SYNCHRONIZED|0x0020|是否为synchronized|\n|7|ACC_BRIDGE|0x0040|是否编译器生成的桥接方法|\n|8|ACC_VARIGES|0x0080|是否接受不定参数|\n|9|ACC_NATIVE|0x010|是否本地方法|\n|11|ACC_ABSTRACT|0x0400|是否抽象方法|\n|12|ACC_STRICTFP|0x0800|是否为strictfp|\n|11|ACC_SYNTHETIC|0x0400|是否由编译器自动产生|\n\n## 属性集合\n\n属性表集合用以描述某些场景的专有信息，CLASS、FILED、METHOD都有携带自己的属性表集合。\n\n### 属性数量（u2）\n\n描述当前属性表的属性数量\n\n### 属性表\n\n属性表至少需包含以下（各类属性表结构略有区别）；\n\n1. u2 属性名对应的简单名称在常量池中的索引(attribute_name_index)\n2. u4 属性长度(attribute_length)\n4. u1 属性表信息（长度为属性长度）\n\n\n属性的描述，在JDK1.7时共有21中属性分类。\n\n根据属性类型的不同，其具体的表数据结构也略有不同，具体请参阅[JAVA虚拟机规范-4.7章节](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7)。\n\nps：属性的CODE类型中，虽规定CODE的长度为u4，但实际指令最长长度不能大于65535。\n\n\n\n\n疑问1：在类中，类的静态变量赋值时（如static a = 1;），“1”这个值存放位置。\n答：作为指令，存放在CLASS的属性表中\n疑问2：对象实例的this，在字节码文件中是否有安排位置存放；\n疑问3：桥接方法？\n疑问4：不定参数的方法描述？\n","slug":"2018-09-13-JVM_CLASS","published":1,"_id":"cjm4a7k3p0006dwvjgrus0ksr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>JAVA语言以及其他运行于JVM上的语言（JRuby、Groovy等）中所定义各种变量、逻辑，通过不同的编译器最终都会被转成字节码文件用于虚拟机执行，甚至一些Java语言无法支持的特性，字节码文件都可以支持，可以看出，字节码文件的重要性。</p>\n<a id=\"more\"></a>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>本质：由一组<strong>8位</strong>字节，严格<strong>按照顺序</strong>，<strong>紧凑</strong>排列组成的<strong>二进制流</strong>。</p>\n<ul>\n<li>8位：CLASS文件的基础单位，超过8为的数据在存放时采用<strong><em>高位在前</em></strong>的存储方式存储。<br>ps：高位在前指的时最高的字节在地址的低位（即访问时先访问到）</li>\n<li>按照顺序：按照虚拟机规范中对字节码文件的定义</li>\n<li>紧凑：各数据之间没有任何分隔符</li>\n<li>二进制流：只要时符合规范的二进制流虚拟机都可识别，也就意味着<strong>CLASS文件的来源不局限于文件系统</strong>。</li>\n</ul>\n<p>数据结构：采用了<strong>无符号数</strong>和<strong>表</strong>这两种伪结构存储数据。  </p>\n<ul>\n<li>无符号数：基本数据类型，以u1、u2、u4和u8分别对应1字节、2字节、4字节和8字节，用以描述数字、索引引用、数量值或UTF-8字符串等。  </li>\n<li>表：由多个无符号数或其他数据项构成，习惯以_info结尾。用以描述由层次关系的复合结构数据。 </li>\n<li>集合（拓展）：用来描述多个连续的无符号数或表，通常会带一个前置容量计数器</li>\n</ul>\n<h1 id=\"字节码文件结构\"><a href=\"#字节码文件结构\" class=\"headerlink\" title=\"字节码文件结构\"></a>字节码文件结构</h1><h2 id=\"结构概览\"><a href=\"#结构概览\" class=\"headerlink\" title=\"结构概览\"></a>结构概览</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:left\">名称</th>\n<th style=\"text-align:center\">数量</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">u4</td>\n<td style=\"text-align:left\">魔数（magic）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">次版本号（minor_version）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">主版本号（major_version）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">常量池常量数（constant_pool_count）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">与constant_pool构成一个表的集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cp_info</td>\n<td style=\"text-align:left\">常量池（constant_pool）</td>\n<td style=\"text-align:center\">常量池常量数</td>\n<td style=\"text-align:left\">每个常量都是一个表，存放放量相关信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">权限标志（access flags）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">本类名（this_class）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">指向常量池中本类的全限定名字符串的索引（第几个）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">父类名（this_class）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">指向常量池中父类的全限定名字符串的索引</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">接口数量（interfaces_count）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">与interfaces组成一个u2的无符号集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">接口（interfaces）</td>\n<td style=\"text-align:center\">接口数量</td>\n<td style=\"text-align:left\">指向常量池中接口的全限定名字符串的索引</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">字段数量（filed_count）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">与filed_info组成字段集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">filed_info</td>\n<td style=\"text-align:left\">字段（filed）</td>\n<td style=\"text-align:center\">字段数量</td>\n<td style=\"text-align:left\">数据结构较复杂</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">方法数量（method_info）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">与method_info组成方法集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">method_info</td>\n<td style=\"text-align:left\">方法（method）</td>\n<td style=\"text-align:center\">方法数量</td>\n<td style=\"text-align:left\">数据结构较复杂</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">属性数量（attribute_count）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">与attribute_info组成属性集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">attribute_info</td>\n<td style=\"text-align:left\">属性（attribute）</td>\n<td style=\"text-align:center\">属性数量</td>\n<td style=\"text-align:left\">数据结构较复杂</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"魔数（u4）\"><a href=\"#魔数（u4）\" class=\"headerlink\" title=\"魔数（u4）\"></a>魔数（u4）</h2><p>固定值：CA FE BA BE<br>用以标识当前文件是给JVM执行的字节码文件</p>\n<h2 id=\"次版本号（u2）\"><a href=\"#次版本号（u2）\" class=\"headerlink\" title=\"次版本号（u2）\"></a>次版本号（u2）</h2><p>标识CLASS文件的次版本号</p>\n<h2 id=\"主版本号（u2）\"><a href=\"#主版本号（u2）\" class=\"headerlink\" title=\"主版本号（u2）\"></a>主版本号（u2）</h2><p>标识CLASS文件的主版本号（JVM执行的版本，非实际JAVA开发版本），从JAVA1.1 到JAVA1.8 分别对应从 45 到 52。</p>\n<h2 id=\"常量池常量数（u2）及常量池（cp-info）\"><a href=\"#常量池常量数（u2）及常量池（cp-info）\" class=\"headerlink\" title=\"常量池常量数（u2）及常量池（cp_info）\"></a>常量池常量数（u2）及常量池（cp_info）</h2><h3 id=\"常量池常量数\"><a href=\"#常量池常量数\" class=\"headerlink\" title=\"常量池常量数\"></a>常量池常量数</h3><ul>\n<li>索引从1开始，即实际常量数是=常量池常量数-1</li>\n<li>索引0主要是为了“表示不引用任何常量池常量”</li>\n</ul>\n<h3 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h3><p>常量池主要存放：字面量和符号引用</p>\n<ul>\n<li>字面量：文本字符串、声明为final的常量值。</li>\n<li>符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</li>\n</ul>\n<p>全限定名：表示类的路径及名称；如”java/lang/Object;”，一般以；标识全限定名的结束。<br>简单名称：标识字段及方法的名称，如字段x，方法int()对应的就是”x，int”<br>描述符：描述字段或方法；如”[Ljava/lang/Object”表示Object[]；”(C[I)V”表示返回值为void，参数为（char，int[]）的方法，诸如此类。</p>\n<p>描述符含义</p>\n<ul>\n<li>B &nbsp;&nbsp;&nbsp;&nbsp; byte</li>\n<li>C &nbsp;&nbsp;&nbsp;&nbsp; char</li>\n<li>D &nbsp;&nbsp;&nbsp;&nbsp; double</li>\n<li>F &nbsp;&nbsp;&nbsp;&nbsp; float</li>\n<li>I &nbsp;&nbsp;&nbsp;&nbsp; int</li>\n<li><strong><em>J</em></strong> &nbsp;&nbsp;&nbsp;&nbsp; long</li>\n<li>S &nbsp;&nbsp;&nbsp;&nbsp; short</li>\n<li><strong><em>Z</em></strong> &nbsp;&nbsp;&nbsp;&nbsp; boolean</li>\n<li>L &nbsp;&nbsp;&nbsp;&nbsp; 对象</li>\n<li>[ &nbsp;&nbsp;&nbsp;&nbsp; 数组，有多个则代表多维，数组类型为[后紧接的描述符</li>\n<li>()  &nbsp;&nbsp;&nbsp; 方法，括号外为返回值类型，括号内为参数类型（各参数之间无逗号） </li>\n</ul>\n<p>常量池中，根据常量类型的不同，其具体的表数据结构也略有不同，待后续整理，具体请参阅<a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4\" target=\"_blank\" rel=\"noopener\">JAVA虚拟机规范-4.4章节</a>。</p>\n<p>ps：因常量池UTF8字符长度的限制，方法最长长度不能大于65535。</p>\n<h2 id=\"访问标志（u2）\"><a href=\"#访问标志（u2）\" class=\"headerlink\" title=\"访问标志（u2）\"></a>访问标志（u2）</h2><p>表示当前类的访问标志，共可设置16种标志，各标志含义如下</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">编号</th>\n<th style=\"text-align:center\">16</th>\n<th style=\"text-align:center\">15</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">13</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">11</th>\n<th style=\"text-align:center\">10</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0x</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">标志名称</th>\n<th style=\"text-align:left\">标志值</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">ACC_PUBLIC</td>\n<td style=\"text-align:left\">0x0001</td>\n<td style=\"text-align:left\">是否为public类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">ACC_FINAL</td>\n<td style=\"text-align:left\">0x0010</td>\n<td style=\"text-align:left\">是否为final类型，只有类才可设置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">ACC_SUPER</td>\n<td style=\"text-align:left\">0x0020</td>\n<td style=\"text-align:left\">改之在1.02后必须为1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\">ACC_INTERFACE</td>\n<td style=\"text-align:left\">0x0200</td>\n<td style=\"text-align:left\">是否为接口</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\">ACC_ABSTRACT</td>\n<td style=\"text-align:left\">0x0400</td>\n<td style=\"text-align:left\">是否为抽象类型，对于接口及抽象类，值为真，其他为假</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">13</td>\n<td style=\"text-align:left\">ACC_SYNTHETIC</td>\n<td style=\"text-align:left\">0x1000</td>\n<td style=\"text-align:left\">这个类不是由用户代码生成（动态标志）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">14</td>\n<td style=\"text-align:left\">ACC_ANNOTATION</td>\n<td style=\"text-align:left\">0x2000</td>\n<td style=\"text-align:left\">是否为注解</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">15</td>\n<td style=\"text-align:left\">ACC_ENUM</td>\n<td style=\"text-align:left\">0x4000</td>\n<td style=\"text-align:left\">是否为枚举类</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"本类名（u2）\"><a href=\"#本类名（u2）\" class=\"headerlink\" title=\"本类名（u2）\"></a>本类名（u2）</h2><p>指向常量池中，类型为CONSTANT_Class_info的常量索引（tag为7）。</p>\n<h2 id=\"父类名（u2）\"><a href=\"#父类名（u2）\" class=\"headerlink\" title=\"父类名（u2）\"></a>父类名（u2）</h2><p>指向常量池中，类型为CONSTANT_Class_info的常量索引（tag为7）。<br>除了Object外，所有的类的父类索引都不为0（因为所有类都继承自Object）</p>\n<h2 id=\"接口集合\"><a href=\"#接口集合\" class=\"headerlink\" title=\"接口集合\"></a>接口集合</h2><h3 id=\"接口数量（u2）\"><a href=\"#接口数量（u2）\" class=\"headerlink\" title=\"接口数量（u2）\"></a>接口数量（u2）</h3><p>标识当前类实现的接口的数量</p>\n<h3 id=\"接口（u2）\"><a href=\"#接口（u2）\" class=\"headerlink\" title=\"接口（u2）\"></a>接口（u2）</h3><p>指向常量池中，类型为CONSTANT_Class_info的常量索引（tag为7）。<br>若类实现多个接口，则按类实现顺序，从左向右一次放入接口集合中。</p>\n<h2 id=\"字段表集合\"><a href=\"#字段表集合\" class=\"headerlink\" title=\"字段表集合\"></a>字段表集合</h2><p>1、字段集合中不会有从父类或父接口中继承来的字段。但可能会出现代码中没有的字段。<br>2、对于字节码而言，只要字段的描述不以相同，即使字段简单名称相同，也会被认为是不同的字段，而JAVA中简单名称必须不同。</p>\n<h3 id=\"字段数量（u2）\"><a href=\"#字段数量（u2）\" class=\"headerlink\" title=\"字段数量（u2）\"></a>字段数量（u2）</h3><p>类或接口中，类级变量及实例级变量的数量（<strong>不包括方法内部声明的变量</strong>）。</p>\n<h3 id=\"字段表\"><a href=\"#字段表\" class=\"headerlink\" title=\"字段表\"></a>字段表</h3><p>字段表主要包含</p>\n<ol>\n<li>u2 字段权限标志（access_flags）</li>\n<li>u2 字段名对应的简单名称在常量池中的索引(name_index)</li>\n<li>u2 字段描述对应的描述符在常量池中索引(descript_index)</li>\n<li>u2 属性表数量（attribute_count）</li>\n<li>attribute_info 属性表信息（attributet）</li>\n</ol>\n<p>其中<br>1.字段权限标志，参照如下表<br>|编号|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|<br>|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|<br>|0x|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">标志名称</th>\n<th style=\"text-align:left\">标志值</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">ACC_PUBLIC</td>\n<td style=\"text-align:left\">0x0001</td>\n<td style=\"text-align:left\">是否为public类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">ACC_PRIVATE</td>\n<td style=\"text-align:left\">0x0002</td>\n<td style=\"text-align:left\">是否为private类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">ACC_PROTECTED</td>\n<td style=\"text-align:left\">0x0004</td>\n<td style=\"text-align:left\">是否为protected类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">ACC_STATIC</td>\n<td style=\"text-align:left\">0x0008</td>\n<td style=\"text-align:left\">是否为static</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">ACC_FINAL</td>\n<td style=\"text-align:left\">0x0010</td>\n<td style=\"text-align:left\">是否为final型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">ACC_VOLATILE</td>\n<td style=\"text-align:left\">0x0040</td>\n<td style=\"text-align:left\">是否为volatile</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">ACC_TRANSIENT</td>\n<td style=\"text-align:left\">0x0080</td>\n<td style=\"text-align:left\">是否为transient</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">13</td>\n<td style=\"text-align:left\">ACC_SYNTHETIC</td>\n<td style=\"text-align:left\">0x1000</td>\n<td style=\"text-align:left\">是否由编译器生成</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">15</td>\n<td style=\"text-align:left\">ACC_ENUM</td>\n<td style=\"text-align:left\">0x4000</td>\n<td style=\"text-align:left\">是否为enum</td>\n</tr>\n</tbody>\n</table>\n<p>其中1、2、3最多只能1个为真；5、7不能同时为真；接口中的字段1、4、5必须为真</p>\n<h2 id=\"方法集合\"><a href=\"#方法集合\" class=\"headerlink\" title=\"方法集合\"></a>方法集合</h2><p>1、方法集合中不会出现没有被重写（override）的父类或父接口方法。但可能会出现代码中没有的方法（典型的如类构造器<clinit> 及初始化方法<init>）。<br>2、对于字节码而言，只要字段的描述不以相同，即使字段简单名称相同，也会被认为是不同的字段，而JAVA中简单名称必须不同。</init></clinit></p>\n<h3 id=\"方法数量（u2）\"><a href=\"#方法数量（u2）\" class=\"headerlink\" title=\"方法数量（u2）\"></a>方法数量（u2）</h3><p>类或接口中，方法的数量。</p>\n<h3 id=\"方法表\"><a href=\"#方法表\" class=\"headerlink\" title=\"方法表\"></a>方法表</h3><p>方法表主要包含</p>\n<ol>\n<li>u2 方法权限标志（access_flags）</li>\n<li>u2 方法名对应的简单名称在常量池中的索引(name_index)</li>\n<li>u2 方法描述对应的描述符在常量池中索引(descript_index)</li>\n<li>u2 属性表数量（attribute_count）</li>\n<li>attribute_info 属性表信息（attributet）</li>\n</ol>\n<p>其中<br>1.字段权限标志，参照如下表<br>|编号|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|<br>|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|<br>|0x|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">标志名称</th>\n<th style=\"text-align:left\">标志值</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">ACC_PUBLIC</td>\n<td style=\"text-align:left\">0x0001</td>\n<td style=\"text-align:left\">是否为public类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">ACC_PRIVATE</td>\n<td style=\"text-align:left\">0x0002</td>\n<td style=\"text-align:left\">是否为private类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">ACC_PROTECTED</td>\n<td style=\"text-align:left\">0x0004</td>\n<td style=\"text-align:left\">是否为protected类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">ACC_STATIC</td>\n<td style=\"text-align:left\">0x0008</td>\n<td style=\"text-align:left\">是否为static</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">ACC_FINAL</td>\n<td style=\"text-align:left\">0x0010</td>\n<td style=\"text-align:left\">是否为final型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">ACC_SYNCHRONIZED</td>\n<td style=\"text-align:left\">0x0020</td>\n<td style=\"text-align:left\">是否为synchronized</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">ACC_BRIDGE</td>\n<td style=\"text-align:left\">0x0040</td>\n<td style=\"text-align:left\">是否编译器生成的桥接方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">ACC_VARIGES</td>\n<td style=\"text-align:left\">0x0080</td>\n<td style=\"text-align:left\">是否接受不定参数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">9</td>\n<td style=\"text-align:left\">ACC_NATIVE</td>\n<td style=\"text-align:left\">0x010</td>\n<td style=\"text-align:left\">是否本地方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\">ACC_ABSTRACT</td>\n<td style=\"text-align:left\">0x0400</td>\n<td style=\"text-align:left\">是否抽象方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">12</td>\n<td style=\"text-align:left\">ACC_STRICTFP</td>\n<td style=\"text-align:left\">0x0800</td>\n<td style=\"text-align:left\">是否为strictfp</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\">ACC_SYNTHETIC</td>\n<td style=\"text-align:left\">0x0400</td>\n<td style=\"text-align:left\">是否由编译器自动产生</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"属性集合\"><a href=\"#属性集合\" class=\"headerlink\" title=\"属性集合\"></a>属性集合</h2><p>属性表集合用以描述某些场景的专有信息，CLASS、FILED、METHOD都有携带自己的属性表集合。</p>\n<h3 id=\"属性数量（u2）\"><a href=\"#属性数量（u2）\" class=\"headerlink\" title=\"属性数量（u2）\"></a>属性数量（u2）</h3><p>描述当前属性表的属性数量</p>\n<h3 id=\"属性表\"><a href=\"#属性表\" class=\"headerlink\" title=\"属性表\"></a>属性表</h3><p>属性表至少需包含以下（各类属性表结构略有区别）；</p>\n<ol>\n<li>u2 属性名对应的简单名称在常量池中的索引(attribute_name_index)</li>\n<li>u4 属性长度(attribute_length)</li>\n<li>u1 属性表信息（长度为属性长度）</li>\n</ol>\n<p>属性的描述，在JDK1.7时共有21中属性分类。</p>\n<p>根据属性类型的不同，其具体的表数据结构也略有不同，具体请参阅<a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7\" target=\"_blank\" rel=\"noopener\">JAVA虚拟机规范-4.7章节</a>。</p>\n<p>ps：属性的CODE类型中，虽规定CODE的长度为u4，但实际指令最长长度不能大于65535。</p>\n<p>疑问1：在类中，类的静态变量赋值时（如static a = 1;），“1”这个值存放位置。<br>答：作为指令，存放在CLASS的属性表中<br>疑问2：对象实例的this，在字节码文件中是否有安排位置存放；<br>疑问3：桥接方法？<br>疑问4：不定参数的方法描述？</p>\n","site":{"data":{}},"excerpt":"<p>JAVA语言以及其他运行于JVM上的语言（JRuby、Groovy等）中所定义各种变量、逻辑，通过不同的编译器最终都会被转成字节码文件用于虚拟机执行，甚至一些Java语言无法支持的特性，字节码文件都可以支持，可以看出，字节码文件的重要性。</p>","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>本质：由一组<strong>8位</strong>字节，严格<strong>按照顺序</strong>，<strong>紧凑</strong>排列组成的<strong>二进制流</strong>。</p>\n<ul>\n<li>8位：CLASS文件的基础单位，超过8为的数据在存放时采用<strong><em>高位在前</em></strong>的存储方式存储。<br>ps：高位在前指的时最高的字节在地址的低位（即访问时先访问到）</li>\n<li>按照顺序：按照虚拟机规范中对字节码文件的定义</li>\n<li>紧凑：各数据之间没有任何分隔符</li>\n<li>二进制流：只要时符合规范的二进制流虚拟机都可识别，也就意味着<strong>CLASS文件的来源不局限于文件系统</strong>。</li>\n</ul>\n<p>数据结构：采用了<strong>无符号数</strong>和<strong>表</strong>这两种伪结构存储数据。  </p>\n<ul>\n<li>无符号数：基本数据类型，以u1、u2、u4和u8分别对应1字节、2字节、4字节和8字节，用以描述数字、索引引用、数量值或UTF-8字符串等。  </li>\n<li>表：由多个无符号数或其他数据项构成，习惯以_info结尾。用以描述由层次关系的复合结构数据。 </li>\n<li>集合（拓展）：用来描述多个连续的无符号数或表，通常会带一个前置容量计数器</li>\n</ul>\n<h1 id=\"字节码文件结构\"><a href=\"#字节码文件结构\" class=\"headerlink\" title=\"字节码文件结构\"></a>字节码文件结构</h1><h2 id=\"结构概览\"><a href=\"#结构概览\" class=\"headerlink\" title=\"结构概览\"></a>结构概览</h2><table>\n<thead>\n<tr>\n<th style=\"text-align:center\">类型</th>\n<th style=\"text-align:left\">名称</th>\n<th style=\"text-align:center\">数量</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">u4</td>\n<td style=\"text-align:left\">魔数（magic）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">次版本号（minor_version）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">主版本号（major_version）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">常量池常量数（constant_pool_count）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">与constant_pool构成一个表的集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">cp_info</td>\n<td style=\"text-align:left\">常量池（constant_pool）</td>\n<td style=\"text-align:center\">常量池常量数</td>\n<td style=\"text-align:left\">每个常量都是一个表，存放放量相关信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">权限标志（access flags）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\"></td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">本类名（this_class）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">指向常量池中本类的全限定名字符串的索引（第几个）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">父类名（this_class）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">指向常量池中父类的全限定名字符串的索引</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">接口数量（interfaces_count）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">与interfaces组成一个u2的无符号集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">接口（interfaces）</td>\n<td style=\"text-align:center\">接口数量</td>\n<td style=\"text-align:left\">指向常量池中接口的全限定名字符串的索引</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">字段数量（filed_count）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">与filed_info组成字段集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">filed_info</td>\n<td style=\"text-align:left\">字段（filed）</td>\n<td style=\"text-align:center\">字段数量</td>\n<td style=\"text-align:left\">数据结构较复杂</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">方法数量（method_info）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">与method_info组成方法集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">method_info</td>\n<td style=\"text-align:left\">方法（method）</td>\n<td style=\"text-align:center\">方法数量</td>\n<td style=\"text-align:left\">数据结构较复杂</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">u2</td>\n<td style=\"text-align:left\">属性数量（attribute_count）</td>\n<td style=\"text-align:center\">1</td>\n<td style=\"text-align:left\">与attribute_info组成属性集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">attribute_info</td>\n<td style=\"text-align:left\">属性（attribute）</td>\n<td style=\"text-align:center\">属性数量</td>\n<td style=\"text-align:left\">数据结构较复杂</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"魔数（u4）\"><a href=\"#魔数（u4）\" class=\"headerlink\" title=\"魔数（u4）\"></a>魔数（u4）</h2><p>固定值：CA FE BA BE<br>用以标识当前文件是给JVM执行的字节码文件</p>\n<h2 id=\"次版本号（u2）\"><a href=\"#次版本号（u2）\" class=\"headerlink\" title=\"次版本号（u2）\"></a>次版本号（u2）</h2><p>标识CLASS文件的次版本号</p>\n<h2 id=\"主版本号（u2）\"><a href=\"#主版本号（u2）\" class=\"headerlink\" title=\"主版本号（u2）\"></a>主版本号（u2）</h2><p>标识CLASS文件的主版本号（JVM执行的版本，非实际JAVA开发版本），从JAVA1.1 到JAVA1.8 分别对应从 45 到 52。</p>\n<h2 id=\"常量池常量数（u2）及常量池（cp-info）\"><a href=\"#常量池常量数（u2）及常量池（cp-info）\" class=\"headerlink\" title=\"常量池常量数（u2）及常量池（cp_info）\"></a>常量池常量数（u2）及常量池（cp_info）</h2><h3 id=\"常量池常量数\"><a href=\"#常量池常量数\" class=\"headerlink\" title=\"常量池常量数\"></a>常量池常量数</h3><ul>\n<li>索引从1开始，即实际常量数是=常量池常量数-1</li>\n<li>索引0主要是为了“表示不引用任何常量池常量”</li>\n</ul>\n<h3 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h3><p>常量池主要存放：字面量和符号引用</p>\n<ul>\n<li>字面量：文本字符串、声明为final的常量值。</li>\n<li>符号引用：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符</li>\n</ul>\n<p>全限定名：表示类的路径及名称；如”java/lang/Object;”，一般以；标识全限定名的结束。<br>简单名称：标识字段及方法的名称，如字段x，方法int()对应的就是”x，int”<br>描述符：描述字段或方法；如”[Ljava/lang/Object”表示Object[]；”(C[I)V”表示返回值为void，参数为（char，int[]）的方法，诸如此类。</p>\n<p>描述符含义</p>\n<ul>\n<li>B &nbsp;&nbsp;&nbsp;&nbsp; byte</li>\n<li>C &nbsp;&nbsp;&nbsp;&nbsp; char</li>\n<li>D &nbsp;&nbsp;&nbsp;&nbsp; double</li>\n<li>F &nbsp;&nbsp;&nbsp;&nbsp; float</li>\n<li>I &nbsp;&nbsp;&nbsp;&nbsp; int</li>\n<li><strong><em>J</em></strong> &nbsp;&nbsp;&nbsp;&nbsp; long</li>\n<li>S &nbsp;&nbsp;&nbsp;&nbsp; short</li>\n<li><strong><em>Z</em></strong> &nbsp;&nbsp;&nbsp;&nbsp; boolean</li>\n<li>L &nbsp;&nbsp;&nbsp;&nbsp; 对象</li>\n<li>[ &nbsp;&nbsp;&nbsp;&nbsp; 数组，有多个则代表多维，数组类型为[后紧接的描述符</li>\n<li>()  &nbsp;&nbsp;&nbsp; 方法，括号外为返回值类型，括号内为参数类型（各参数之间无逗号） </li>\n</ul>\n<p>常量池中，根据常量类型的不同，其具体的表数据结构也略有不同，待后续整理，具体请参阅<a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.4\" target=\"_blank\" rel=\"noopener\">JAVA虚拟机规范-4.4章节</a>。</p>\n<p>ps：因常量池UTF8字符长度的限制，方法最长长度不能大于65535。</p>\n<h2 id=\"访问标志（u2）\"><a href=\"#访问标志（u2）\" class=\"headerlink\" title=\"访问标志（u2）\"></a>访问标志（u2）</h2><p>表示当前类的访问标志，共可设置16种标志，各标志含义如下</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">编号</th>\n<th style=\"text-align:center\">16</th>\n<th style=\"text-align:center\">15</th>\n<th style=\"text-align:center\">14</th>\n<th style=\"text-align:center\">13</th>\n<th style=\"text-align:center\">12</th>\n<th style=\"text-align:center\">11</th>\n<th style=\"text-align:center\">10</th>\n<th style=\"text-align:center\">9</th>\n<th style=\"text-align:center\">8</th>\n<th style=\"text-align:center\">7</th>\n<th style=\"text-align:center\">6</th>\n<th style=\"text-align:center\">5</th>\n<th style=\"text-align:center\">4</th>\n<th style=\"text-align:center\">3</th>\n<th style=\"text-align:center\">2</th>\n<th style=\"text-align:center\">1</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">0x</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">0</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">标志名称</th>\n<th style=\"text-align:left\">标志值</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">ACC_PUBLIC</td>\n<td style=\"text-align:left\">0x0001</td>\n<td style=\"text-align:left\">是否为public类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">ACC_FINAL</td>\n<td style=\"text-align:left\">0x0010</td>\n<td style=\"text-align:left\">是否为final类型，只有类才可设置</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">ACC_SUPER</td>\n<td style=\"text-align:left\">0x0020</td>\n<td style=\"text-align:left\">改之在1.02后必须为1</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">10</td>\n<td style=\"text-align:left\">ACC_INTERFACE</td>\n<td style=\"text-align:left\">0x0200</td>\n<td style=\"text-align:left\">是否为接口</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\">ACC_ABSTRACT</td>\n<td style=\"text-align:left\">0x0400</td>\n<td style=\"text-align:left\">是否为抽象类型，对于接口及抽象类，值为真，其他为假</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">13</td>\n<td style=\"text-align:left\">ACC_SYNTHETIC</td>\n<td style=\"text-align:left\">0x1000</td>\n<td style=\"text-align:left\">这个类不是由用户代码生成（动态标志）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">14</td>\n<td style=\"text-align:left\">ACC_ANNOTATION</td>\n<td style=\"text-align:left\">0x2000</td>\n<td style=\"text-align:left\">是否为注解</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">15</td>\n<td style=\"text-align:left\">ACC_ENUM</td>\n<td style=\"text-align:left\">0x4000</td>\n<td style=\"text-align:left\">是否为枚举类</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"本类名（u2）\"><a href=\"#本类名（u2）\" class=\"headerlink\" title=\"本类名（u2）\"></a>本类名（u2）</h2><p>指向常量池中，类型为CONSTANT_Class_info的常量索引（tag为7）。</p>\n<h2 id=\"父类名（u2）\"><a href=\"#父类名（u2）\" class=\"headerlink\" title=\"父类名（u2）\"></a>父类名（u2）</h2><p>指向常量池中，类型为CONSTANT_Class_info的常量索引（tag为7）。<br>除了Object外，所有的类的父类索引都不为0（因为所有类都继承自Object）</p>\n<h2 id=\"接口集合\"><a href=\"#接口集合\" class=\"headerlink\" title=\"接口集合\"></a>接口集合</h2><h3 id=\"接口数量（u2）\"><a href=\"#接口数量（u2）\" class=\"headerlink\" title=\"接口数量（u2）\"></a>接口数量（u2）</h3><p>标识当前类实现的接口的数量</p>\n<h3 id=\"接口（u2）\"><a href=\"#接口（u2）\" class=\"headerlink\" title=\"接口（u2）\"></a>接口（u2）</h3><p>指向常量池中，类型为CONSTANT_Class_info的常量索引（tag为7）。<br>若类实现多个接口，则按类实现顺序，从左向右一次放入接口集合中。</p>\n<h2 id=\"字段表集合\"><a href=\"#字段表集合\" class=\"headerlink\" title=\"字段表集合\"></a>字段表集合</h2><p>1、字段集合中不会有从父类或父接口中继承来的字段。但可能会出现代码中没有的字段。<br>2、对于字节码而言，只要字段的描述不以相同，即使字段简单名称相同，也会被认为是不同的字段，而JAVA中简单名称必须不同。</p>\n<h3 id=\"字段数量（u2）\"><a href=\"#字段数量（u2）\" class=\"headerlink\" title=\"字段数量（u2）\"></a>字段数量（u2）</h3><p>类或接口中，类级变量及实例级变量的数量（<strong>不包括方法内部声明的变量</strong>）。</p>\n<h3 id=\"字段表\"><a href=\"#字段表\" class=\"headerlink\" title=\"字段表\"></a>字段表</h3><p>字段表主要包含</p>\n<ol>\n<li>u2 字段权限标志（access_flags）</li>\n<li>u2 字段名对应的简单名称在常量池中的索引(name_index)</li>\n<li>u2 字段描述对应的描述符在常量池中索引(descript_index)</li>\n<li>u2 属性表数量（attribute_count）</li>\n<li>attribute_info 属性表信息（attributet）</li>\n</ol>\n<p>其中<br>1.字段权限标志，参照如下表<br>|编号|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|<br>|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|<br>|0x|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">标志名称</th>\n<th style=\"text-align:left\">标志值</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">ACC_PUBLIC</td>\n<td style=\"text-align:left\">0x0001</td>\n<td style=\"text-align:left\">是否为public类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">ACC_PRIVATE</td>\n<td style=\"text-align:left\">0x0002</td>\n<td style=\"text-align:left\">是否为private类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">ACC_PROTECTED</td>\n<td style=\"text-align:left\">0x0004</td>\n<td style=\"text-align:left\">是否为protected类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">ACC_STATIC</td>\n<td style=\"text-align:left\">0x0008</td>\n<td style=\"text-align:left\">是否为static</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">ACC_FINAL</td>\n<td style=\"text-align:left\">0x0010</td>\n<td style=\"text-align:left\">是否为final型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">ACC_VOLATILE</td>\n<td style=\"text-align:left\">0x0040</td>\n<td style=\"text-align:left\">是否为volatile</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">ACC_TRANSIENT</td>\n<td style=\"text-align:left\">0x0080</td>\n<td style=\"text-align:left\">是否为transient</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">13</td>\n<td style=\"text-align:left\">ACC_SYNTHETIC</td>\n<td style=\"text-align:left\">0x1000</td>\n<td style=\"text-align:left\">是否由编译器生成</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">15</td>\n<td style=\"text-align:left\">ACC_ENUM</td>\n<td style=\"text-align:left\">0x4000</td>\n<td style=\"text-align:left\">是否为enum</td>\n</tr>\n</tbody>\n</table>\n<p>其中1、2、3最多只能1个为真；5、7不能同时为真；接口中的字段1、4、5必须为真</p>\n<h2 id=\"方法集合\"><a href=\"#方法集合\" class=\"headerlink\" title=\"方法集合\"></a>方法集合</h2><p>1、方法集合中不会出现没有被重写（override）的父类或父接口方法。但可能会出现代码中没有的方法（典型的如类构造器<clinit> 及初始化方法<init>）。<br>2、对于字节码而言，只要字段的描述不以相同，即使字段简单名称相同，也会被认为是不同的字段，而JAVA中简单名称必须不同。</init></clinit></p>\n<h3 id=\"方法数量（u2）\"><a href=\"#方法数量（u2）\" class=\"headerlink\" title=\"方法数量（u2）\"></a>方法数量（u2）</h3><p>类或接口中，方法的数量。</p>\n<h3 id=\"方法表\"><a href=\"#方法表\" class=\"headerlink\" title=\"方法表\"></a>方法表</h3><p>方法表主要包含</p>\n<ol>\n<li>u2 方法权限标志（access_flags）</li>\n<li>u2 方法名对应的简单名称在常量池中的索引(name_index)</li>\n<li>u2 方法描述对应的描述符在常量池中索引(descript_index)</li>\n<li>u2 属性表数量（attribute_count）</li>\n<li>attribute_info 属性表信息（attributet）</li>\n</ol>\n<p>其中<br>1.字段权限标志，参照如下表<br>|编号|16|15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|<br>|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|:–:|<br>|0x|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|0|</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">编号</th>\n<th style=\"text-align:left\">标志名称</th>\n<th style=\"text-align:left\">标志值</th>\n<th style=\"text-align:left\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">ACC_PUBLIC</td>\n<td style=\"text-align:left\">0x0001</td>\n<td style=\"text-align:left\">是否为public类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">ACC_PRIVATE</td>\n<td style=\"text-align:left\">0x0002</td>\n<td style=\"text-align:left\">是否为private类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">ACC_PROTECTED</td>\n<td style=\"text-align:left\">0x0004</td>\n<td style=\"text-align:left\">是否为protected类型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">ACC_STATIC</td>\n<td style=\"text-align:left\">0x0008</td>\n<td style=\"text-align:left\">是否为static</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">ACC_FINAL</td>\n<td style=\"text-align:left\">0x0010</td>\n<td style=\"text-align:left\">是否为final型</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">ACC_SYNCHRONIZED</td>\n<td style=\"text-align:left\">0x0020</td>\n<td style=\"text-align:left\">是否为synchronized</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">ACC_BRIDGE</td>\n<td style=\"text-align:left\">0x0040</td>\n<td style=\"text-align:left\">是否编译器生成的桥接方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">8</td>\n<td style=\"text-align:left\">ACC_VARIGES</td>\n<td style=\"text-align:left\">0x0080</td>\n<td style=\"text-align:left\">是否接受不定参数</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">9</td>\n<td style=\"text-align:left\">ACC_NATIVE</td>\n<td style=\"text-align:left\">0x010</td>\n<td style=\"text-align:left\">是否本地方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\">ACC_ABSTRACT</td>\n<td style=\"text-align:left\">0x0400</td>\n<td style=\"text-align:left\">是否抽象方法</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">12</td>\n<td style=\"text-align:left\">ACC_STRICTFP</td>\n<td style=\"text-align:left\">0x0800</td>\n<td style=\"text-align:left\">是否为strictfp</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">11</td>\n<td style=\"text-align:left\">ACC_SYNTHETIC</td>\n<td style=\"text-align:left\">0x0400</td>\n<td style=\"text-align:left\">是否由编译器自动产生</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"属性集合\"><a href=\"#属性集合\" class=\"headerlink\" title=\"属性集合\"></a>属性集合</h2><p>属性表集合用以描述某些场景的专有信息，CLASS、FILED、METHOD都有携带自己的属性表集合。</p>\n<h3 id=\"属性数量（u2）\"><a href=\"#属性数量（u2）\" class=\"headerlink\" title=\"属性数量（u2）\"></a>属性数量（u2）</h3><p>描述当前属性表的属性数量</p>\n<h3 id=\"属性表\"><a href=\"#属性表\" class=\"headerlink\" title=\"属性表\"></a>属性表</h3><p>属性表至少需包含以下（各类属性表结构略有区别）；</p>\n<ol>\n<li>u2 属性名对应的简单名称在常量池中的索引(attribute_name_index)</li>\n<li>u4 属性长度(attribute_length)</li>\n<li>u1 属性表信息（长度为属性长度）</li>\n</ol>\n<p>属性的描述，在JDK1.7时共有21中属性分类。</p>\n<p>根据属性类型的不同，其具体的表数据结构也略有不同，具体请参阅<a href=\"https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.7\" target=\"_blank\" rel=\"noopener\">JAVA虚拟机规范-4.7章节</a>。</p>\n<p>ps：属性的CODE类型中，虽规定CODE的长度为u4，但实际指令最长长度不能大于65535。</p>\n<p>疑问1：在类中，类的静态变量赋值时（如static a = 1;），“1”这个值存放位置。<br>答：作为指令，存放在CLASS的属性表中<br>疑问2：对象实例的this，在字节码文件中是否有安排位置存放；<br>疑问3：桥接方法？<br>疑问4：不定参数的方法描述？</p>"}],"PostAsset":[{"_id":"source/_posts/2018-09-11-JVM_BASIC_Memory/RuntimeMemory.png","slug":"RuntimeMemory.png","post":"cjm4a7k3o0005dwvjfo0xf846","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-08-Markdown_basic/googlelogo.png","slug":"googlelogo.png","post":"cjm4a7k3f0000dwvj2srpthyz","modified":0,"renderable":0},{"_id":"source/_posts/2018-09-11-JVM_BASIC_Memory/DirectBuffer.png","slug":"DirectBuffer.png","post":"cjm4a7k3o0005dwvjfo0xf846","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjm4a7k3f0000dwvj2srpthyz","category_id":"cjm4a7k3l0002dwvjzvag6yzi","_id":"cjm4a7k3s0009dwvjncfpgzwi"},{"post_id":"cjm4a7k3j0001dwvj5gbl1ktl","category_id":"cjm4a7k3q0007dwvjfuggxwed","_id":"cjm4a7k3v000edwvjmxml11mx"},{"post_id":"cjm4a7k3n0004dwvjuthywlk8","category_id":"cjm4a7k3s000adwvjrl60erkt","_id":"cjm4a7k40000sdwvj0nz1fmwe"},{"post_id":"cjm4a7k3o0005dwvjfo0xf846","category_id":"cjm4a7k3s000adwvjrl60erkt","_id":"cjm4a7k41000vdwvj8s9ar1ug"},{"post_id":"cjm4a7k3p0006dwvjgrus0ksr","category_id":"cjm4a7k3s000adwvjrl60erkt","_id":"cjm4a7k41000xdwvjvse2mssz"}],"PostTag":[{"post_id":"cjm4a7k3f0000dwvj2srpthyz","tag_id":"cjm4a7k3m0003dwvjg9bcqlbj","_id":"cjm4a7k3u000cdwvjc5qlg7o2"},{"post_id":"cjm4a7k3f0000dwvj2srpthyz","tag_id":"cjm4a7k3q0008dwvj5blnv5o4","_id":"cjm4a7k3u000ddwvjha0yr0s4"},{"post_id":"cjm4a7k3j0001dwvj5gbl1ktl","tag_id":"cjm4a7k3q0008dwvj5blnv5o4","_id":"cjm4a7k3x000jdwvjn9m1llqq"},{"post_id":"cjm4a7k3j0001dwvj5gbl1ktl","tag_id":"cjm4a7k3v000fdwvjd05w8yfq","_id":"cjm4a7k3x000kdwvjirhivny1"},{"post_id":"cjm4a7k3n0004dwvjuthywlk8","tag_id":"cjm4a7k3w000idwvj3yzccep1","_id":"cjm4a7k3y000ndwvjw0ptex2h"},{"post_id":"cjm4a7k3o0005dwvjfo0xf846","tag_id":"cjm4a7k3x000mdwvjmnnk9fzg","_id":"cjm4a7k3z000qdwvj3q204dw6"},{"post_id":"cjm4a7k3p0006dwvjgrus0ksr","tag_id":"cjm4a7k3z000pdwvjgqdxgclm","_id":"cjm4a7k40000udwvjo2b888fl"},{"post_id":"cjm4a7k3o0005dwvjfo0xf846","tag_id":"cjm4afdwl0000qwvjy3mxe7l0","_id":"cjm4afdwp0001qwvjbsup9whg"},{"post_id":"cjm4a7k3n0004dwvjuthywlk8","tag_id":"cjm4afdwl0000qwvjy3mxe7l0","_id":"cjm4afdxc0002qwvjg3ad7gx7"},{"post_id":"cjm4a7k3p0006dwvjgrus0ksr","tag_id":"cjm4afdwl0000qwvjy3mxe7l0","_id":"cjm4afdxd0003qwvj83ljmjtc"}],"Tag":[{"name":"markdown","_id":"cjm4a7k3m0003dwvjg9bcqlbj"},{"name":"Synopsis","_id":"cjm4a7k3q0008dwvj5blnv5o4"},{"name":"install","_id":"cjm4a7k3v000fdwvjd05w8yfq"},{"name":"GC","_id":"cjm4a7k3w000idwvj3yzccep1"},{"name":"内存分配","_id":"cjm4a7k3x000mdwvjmnnk9fzg"},{"name":"字节码","_id":"cjm4a7k3z000pdwvjgqdxgclm"},{"name":"JVM","_id":"cjm4afdwl0000qwvjy3mxe7l0"}]}}