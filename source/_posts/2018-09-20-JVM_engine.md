---
title: 深入理解JAVA虚拟机（六） 虚拟机执行引擎
date: 2018/9/20 19:53:59
updated: 
tag: 
- JVM
- 字节码
categories:
- JAVA
---

JAVA虚拟机规范规定了虚拟机执行引擎的概念模型（外观），即输入的字节码文件，过程时解析字节码的过程，输出的是执行结果。

本章主要讲述JAVA字节码的执行引擎。

<!-- more -->

# 再谈栈帧

## 栈帧

* 根据java运行时数据区模型，每个线程都有自己的虚拟机栈，栈帧是虚拟机栈的出栈和入栈的单元。
* 栈帧包含局部变量表、操作数栈、动态连接、方法返回地址及额外信息。其中，局部变量表及操作数栈的大小深度在编译时已经确定，并写入方法的CODE属性表中。
* 在活动线程中，只有在栈顶的栈帧才是有效的，称为当前栈帧，与这个栈帧关联的方法称为当前方法。执行引擎执行的所有字节码都是针对当前栈帧。

### 局部变量表

* 局部变量表的容量大小存等于方法的Code属性的max_locals数据定义局部变量表的最大容量
* 局部变量表的最小单位为变量槽（variable slot），要求：一个slot要能存放一个boolean、byte、char、short、int、float、reference或returnAddress，而long和double需要占用两个slot，但未明确指定1个slot为32位。
* solt可根据虚拟机的位数进行实现，但是64位的虚拟机在存放long和double时仍需要高位对齐和补白以保证在外观上与32位一致。
* 虚拟机未规定reference的长度及数据结构，但需保证：1、能通过该引用直接或间接定位到堆中的数据存放起始地址，2、能通过该应用直接或间接定位到方法区中的类信息
* 局部变量表的索引从0值开始，对于非静态方法，第0位存储的时当前方法的实例对象的引用。
* 虚拟机在类加载检验阶段会对局部变量表的访问进行校验，避免出现单独访问long或double数据类型的某一个slot，若出现，直接报错。
* **slot可重用，但在被重用前，该slot的值不会被擦除**，同时也就决定，局部变量表中的数据必须先赋值再使用。

### 操作数栈

* 后入先出
* 操作数栈的深度在编译阶段就写入方法的CODE属性的max_stacks中
* 编译器在编译时，必须保证操作数栈的数据类型与字节码指令的序列严格匹配。
* 在虚拟机模型中，各栈帧是独立的，但是在实际实现中，会做一些优化，栈帧的部分可能会重叠。

### 动态连接

* 栈帧中包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法的调用过程中的动态连接。
* 字节码中的**方法调用**就是以**常量池中指向方法的符号引**用作为**参数**，一部分在类加载或第一次使用时转化称为直接引用(静态解析)，另一部分在每一次运行期间转化为直接引用（动态解析）。


### 方法返回地址

* 方法执行退出的方式：1、遇到方法返回的字节码指令，正常退出（返回值由具体指令决定），返回的地址可能由栈帧保存，2、遇到异常（无返回值），返回地址由异常处理表确定。

### 附加信息

虚拟机调试信息等。

# 方法调用

* 方法调用指的是确定方法的执行版本，不涉及具体方法内部的逻辑的执行。
* 在程序运行时，方法调用是最普通、最频繁的操作。
* 由于CLASS文件编译过程中不存在连接步骤，字节码文件中仅存放方法的符号引用，在运行时方法的执行内存地址（直接引用）必须要在类加载甚至运行期间才能确定。

## 解析

在类加载的解析阶段，满足下列条件的符号引用，会被转化为直接引用（这种方法的调用过程也叫解析）：

* 主要包含：静态方法（类型直接关联）、私有方法（外部不可访问）、构造器、父类方法、final方法
* 总原则：编译期可知，运行时不可变（在运行前就有一个确定的可调用版本，这个可调用版本在运行期间不可变）
* 字节码体现：invokestatic（调用静态方法）及invokespecial（调用实例构造器的<init>方法、私有方法和父类方法）

## 分派

分派调用时多态特征的一种最基本体现。

### 静态分派

* 虚拟机在重载（overload，方法名相同，参数不同）时，会根据参数的静态类型（外观类型）进行分派，决定使用哪个重载版本，并将该方法的符号引用写到invokevirtual指令中。
* 静态分派只能确定一个“更加合适的”版本
* 与解析并非二选一关系，如静态方法的重载

### 动态分派

* 虚拟机在重写（override，子类覆写父类的方法）时会根据参数的实际类型进行派发。
* 虚拟机在执行invokevirtual时，会先在栈顶元素指向的类的实际对象中，查找方法的描述符和简单名称都相等的方法
* 若找到，则进行权限验证，符合则直接返回当前直接引用，否则抛出java.lang.IllegalAccessErrors
* 若未找到，则在继承关系从下往上查找并验证
* 若找不到，则抛出java.lang.AbstractMethodError

### 多分派与单分派

* 宗量：方法的接收者和方法的参数同称
* 单分派：根据一个宗量进行分配
* 多分派：根据多个宗量进行分配
* 静态分派时：根据方法的接收者和参数名称进行分派，因此时多分派
* 动态分派时：根据方法的接收者进行分派，因此是单分派
总结：**JAvA1.8及前序版本**，都属于静态多分派，动态单分派。

### 虚拟机动态分配的实现

* 问题：动态分派非常频繁，在动态分派时，需要在运行时对类的法国法的元数据中进行搜索，影响性能
* 解决：在**类的方法区**设置虚方法表（virtual method table，vtable）及接口方法表（Interface Method table，itable）
* 原理：在虚方法表存放各个方法的实际入口地址，若方法在子类中没被重写，则虚方法表中的地址与父类相同，若被重写，则替换为子类的地址。
* 具有相同签名的方法，在父类和子类的虚方法表中，应该都由一样的索引。
* 虚方法表在类加载的连接阶段进行初始化，准备额类的变量初始值后，类的方法表也会被初始化。
* 优势：稳定


# 基于栈的字节码解释引擎

## 编译执行和解释执行

|类型|概念|优点|缺点|
|--|--|--|--|
|解释执行|对源语言写成的源语句进行一句一句的翻译，翻译一句就提交给计算机执行一句，不会形成目标程序|翻译简单|运行速度慢|
|编译执行|对源程序进行一个编译，生成一个目标文件，计算机再对这个目标程序进行执行|执行速度较快|翻译的过程要复杂（通常要对代码进行语法分析，还要对代码进行优化，并分配内存，最后形成目标文件）|

现代经典编译思路：在执行前进行语义分析和语法分析处理，把源码转换为抽象语法树。

## 基于栈的指令集和基于内存的指令集

|类型|优点|缺点|
|--|--|--|
|基于栈|可移植|速度慢|
|基于寄存器|速度快|受硬件限制|
